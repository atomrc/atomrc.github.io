<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="alternate" type="application/rss+xml" title="Thomas Belin's Blog" href="https://blog.atomrc.dev/feed.xml"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><title>Javascript : Single-threaded et asynchrone - Thomas Belin</title><meta name="description" content="Comment Javascript fait pour &ecirc;tre &agrave; la fois single-threaded et asynchrone."><meta name="robots" content="index,follow"><meta name="author" content="Thomas Belin"><link rel="canonical" href="https://blog.atomrc.dev/p/javascript-single-threaded-et-asynchrone/"><meta property="og:title" content="Javascript : Single-threaded et asynchrone - Thomas Belin"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.atomrc.dev/p/javascript-single-threaded-et-asynchrone/"><meta property="og:description" content="Comment Javascript fait pour &ecirc;tre &agrave; la fois single-threaded et asynchrone."><meta property="og:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@atomrc"><meta name="twitter:url" content="https://blog.atomrc.dev/p/javascript-single-threaded-et-asynchrone/"><meta name="twitter:title" content="Javascript : Single-threaded et asynchrone - Thomas Belin"><meta name="twitter:description" content="Comment Javascript fait pour &ecirc;tre &agrave; la fois single-threaded et asynchrone."><meta name="twitter:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300"><meta name="theme-color" content="#ffffff"><style>body{--ff-sans:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI","Ubuntu","Roboto","Noto Sans","Droid Sans",sans-serif;--ff-mono:ui-monospace,"Cascadia Mono","Segoe UI Mono","Ubuntu Mono","Roboto Mono",Menlo,Monaco,Consolas,monospace;padding:0;margin:0;color:#333;background-color:#fff;font-family:var(--ff-sans);font-size:13pt}a{text-decoration:none;color:#0e4db5}ul{list-style:none;padding:0}.avatar{height:100px;width:100px;border-radius:50px}.title{color:#e7005d}.tag{font-size:10pt;color:#555;font-style:italic}#header{text-align:center;font-size:1.95em;padding:1em}#header .title{text-shadow:1px 1px 0 #fff;color:inherit;font-weight:200}#footer{text-align:center;padding:2em}.love{color:red}#footer a{color:inherit;text-decoration:underline}</style><script async defer="defer" data-domain="atomrc.dev" src="https://plausible.io/js/plausible.js"></script></head><body><div id="header"><div><a href="/"><img class="avatar" src="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=200" alt="Avatar"></a><br><a class="title" href="/"><span rel="author">Thomas Belin</span></a><br></div></div><section><link href="/css/article.css" rel="stylesheet" async defer="defer"><link href="/css/syntax.css" rel="stylesheet" async defer="defer"><style>article{max-width:800px;margin:auto;padding:0 1em;position:relative;line-height:1.5em}article h1{font-size:2em;font-weight:300}article h2,article h3{position:relative;padding-bottom:.3em;font-weight:500}article h2{font-size:2em;border-bottom:solid 1px #eee;margin:1em 0 .5em}article h3{font-size:1.5em;margin:1em 2em}article ul{list-style-type:disc;padding:0 2em}article img{border:solid 1px grey;display:block;max-width:90%;margin:auto}</style><article lang="fr"><header><h1 class="title">Javascript : Single-threaded et asynchrone</h1><aside><time class="folded-paper" datetime="Sat Jun 01 2013 00:00:00 GMT+0000 (Coordinated Universal Time)" pubdate itemprop="datePublished" content="Sat Jun 01 2013 00:00:00 GMT+0000 (Coordinated Universal Time)">01 <span class="month">Jun</span> 2013</time><br><span class="tag">posts</span>&nbsp; <span class="tag">JavaScript</span>&nbsp; <span class="tag">Internals</span>&nbsp;</aside></header><div class="article-body"><p>Javascript est single-threaded, c'est quelque chose qui est rentré dans la tête de la plupart des développeurs front-end. Cependant ce à quoi on ne réfléchit pas assez c'est : comment est-il possible d'être à la fois single-threaded et de gérer du code asynchrone.</p><h2 id="les-cons%C3%A9quences-du-thread-unique">Les conséquences du thread unique</h2><p>Bon c'est bien beau de savoir que Javascript ne dispose que d'un seul thread mais commençons par voir ce que ça implique ?</p><p>Les bons côtés :</p><ul><li>jamais d'accès concurrents aux données ;</li><li>Le debuggage est nettement simplifié.</li></ul><p>Les mauvais côtés :</p><ul><li>Vous pouvez bloquer votre application avec du code un peu trop gourmand ;</li><li>On ne peut pas faire confiance aux timers (setTimeout et setInterval) qui ont une précision approximative.</li></ul><p>Pour se convaincre à la fois des bons et des mauvais côtés voici un petit bout de code qui va l'illustrer. Considérez le code suivant :</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"start"</span><span class="token punctuation">;</span><br><br>window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    a <span class="token operator">=</span> <span class="token string">"done"</span><span class="token punctuation">;</span><br>    <span class="token function">importantThingToDo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -> "done"</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token function">timeConsumingFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -> "start"</span></code></pre><p>Dans ce code, je suis sûr et certain que ma console affichera &quot;start&quot; en premier même si l'exécution de timeConsumingFunction() prend bien plus de 100ms. Si setTimeout avait créé un nouveau thread, je n'aurais pas pu prédire si ma console allait afficher &quot;start&quot; puis &quot;done&quot; ou le contraire. Autre chose à prendre en compte, si l'exécution de timeConsumingFunction prend plus que 100ms, importantThingToDo sera retardée. Si vous ajoutez à ça des interactions utilisateurs, vous pourrez encore retarder un peu son exécution.</p><h2 id="les-timers">Les timers</h2><p>Les timers (setTimeout et setInterval) sont nos outils pour faire du code asynchrone avec Javascript. On se donnerait presque l'impression qu'on créé des threads et pourtant ... En réalité il ne faut pas voir les timers comme des fonctions asynchrones mais plutôt comme des gestionnaires de queue. Et oui, la fonction principale des timers est d'empiler des fonctions qui seront exécutées séquentiellement et au plus tôt n millisecondes plus tard. Le paramètre de temps prend alors une signification un peu différente de celle à laquelle on pourrait penser. Au lieu de :</p><ul><li>&quot;Exécute cette fonction dans n millisecondes&quot;</li></ul><p>il faut plutôt avoir en tête :</p><ul><li>&quot;Dès que tu es dispo après n millisecondes, exécute cette fonction&quot;</li></ul><p>D'où la faible fiabilité des timers Javascript.</p><p>Pour une explication un peu plus complète sur le fonctionnement des timers de Javascript, je vous invite à lire l'article <a href="http://ejohn.org/blog/how-javascript-timers-work/">How JavaScript Timers Work</a> de John Resig dont je me suis beaucoup inspiré pour mon article.</p><h2 id="les-%C3%A9v%C3%A9nements%2C-le-secret-des-op%C3%A9rations-asynchrones">Les événements, le secret des opérations asynchrones</h2><p>Vous avez dû souvent aussi entendre que Javascript était Event Driven et en effet, si vous y regardez de plus près, l'exécution de code Javascript se fait toujours dans le cadre d'un événement envoyé par le navigateur (load, click, mouseover, progress ...). Ensuite c'est à vous, développeur, de définir ce qu'il va se passer en fonction de ces événements.</p><p>Je disais dans la section sur les timers que les timers empilaient des fonctions Javascript, en réalité c'est le navigateur qui s'occupe de cette tâche. Le navigateur va utiliser un timer interne (qui lui est précis) et enregistrer votre callback sur l'événement de fin de timer. Au bout des n que vous aurez définit, il va ajouter dans la pile d'exécution du moteur Javascript la fonction que vous aurez affecter au timer. Dès que le moteur Javascript sera libre, il s'occupera alors de votre callback.</p><p>Ce schéma se retrouve pour tous les événements qui se produisent dans le navigateur. Prenons l'exemple du clic, voici ce qui se passe quand l'utilisateur clique sur un élément :</p><ul><li>le navigateur intercepte le clic ;</li><li>il vérifie les listeners que vous aurez définis ;</li><li>il les ajoute dans la pile d'exécution de Javascript ;</li><li>quand le moteur est disponible, il exécute chacun des listeners ;</li><li>à la fin de chaque listener le navigateur joue l'action par défaut (par exemple naviguer lors d'un clic sur un lien) si aucun des listeners n'a joué preventDefault() sur l'événement.</li></ul><p>Toutes les actions asynchrones de Javascript fonctionnent sur ce modèle. Par exemple les requêtes XMLHttpRequest laissent au navigateur le soin de faire la requête puis de prévenir le moteur JS une fois que la requête est finie. Seulement contrairement aux timers, vous ne pourrez jamais prédire quand une requête AJAX sera finie. Par exemple le code suivant :</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>request<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'/url'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>request<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request done'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br>request<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout ended'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Vous ne pourrez pas dire si votre console va vous afficher &quot;request done&quot; puis &quot;timeout ended&quot; ou le contraire puisque vous n'avez aucune idée de quand l'événement load sera lancé.</p><h2 id="conclusion">Conclusion</h2><p>Je pense qu'il est important de bien comprendre le fonctionnement interne des technologies que nous utilisons afin de bien les utiliser. Pour Javascript, S'il y a bien quelque chose à retenir c'est que Javascript n'éxécute qu'un seul morceau de code à la fois ! En gardant bien ça en tête vous verrez que certains comportements que vous ne vous expliquiez pas deviendrons clair.</p><p>Et juste pour voir si vous avez bien compris, que donnera l'exécution de ce bout de code ? (Pas le droit d'utiliser sa console hein ;) )</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span><br>    i<span class="token punctuation">;</span><br><br>window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    a <span class="token operator">+=</span> <span class="token string">'Batman'</span><span class="token punctuation">;</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    a <span class="token operator">+=</span> <span class="token string">'nan '</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>NB : Sachez tout de même qu'il existe maintenant les <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers">web workers</a> qui permettent de créer des threads sur lesquels vous avez la main.</p></div><br><em>You enjoyed this article? Consider <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/intent/tweet?url=https://blog.atomrc.dev/p/javascript-single-threaded-et-asynchrone/&text=Javascript : Single-threaded et asynchrone&via=atomrc">tweeting it</a> :)</em></article><script src="/js/application.js" async></script><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebSite",
      "@id": "https://blog.atomrc.dev#website",
      "url": "https://blog.atomrc.dev",
      "name": "Thomas Belin",
      "description": "Senior Front-End Architect @deezer in Paris. I leave code cleaner than I found it. Seriously into Functional and Reactive Programming.",
      "inLanguage": "fr"
    },
    {
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.atomrc.dev/p/javascript-single-threaded-et-asynchrone/"
      },
      "url": "https://blog.atomrc.dev/p/javascript-single-threaded-et-asynchrone/",
      "isPartOf": {
        "@id": "https://blog.atomrc.dev#website"
      },
      "headline": "Javascript : Single-threaded et asynchrone",
      "description": "Comment Javascript fait pour être à la fois single-threaded et asynchrone.",
      "image": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
      "inLanguage": "fr",
      "publisher": {
        "@type": "Organization",
        "name": "Thomas Belin",
        "url": "https://blog.atomrc.dev",
        "logo": {
          "@type": "ImageObject",
          "url": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
          "width": 300,
          "height": 300
        }
      },
      "author": {
        "@type": "Person",
        "name": "Thomas Belin"
      },
      "keywords": "posts,JavaScript,Internals",
      "datePublished": "2013-06-01T00:00:00.000Z"
    }
  ]
}</script></section><div id="footer">Made with <span class="love">♥</span>️ by <a href="https://twitter.com/atomrc" rel="noopener noreferrer">@atomrc</a></div></body></html>