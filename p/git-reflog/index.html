<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="alternate" type="application/rss+xml" title="Thomas Belin's Blog" href="https://blog.atomrc.dev/feed.xml"><link rel="icon" href="/favicon.ico"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><title>Recovering lost commits with git reflog - Thomas Belin</title><meta name="description" content="Any move you make in a git repository is recorded by git. Let's use this to our advantage and never lose a commit again!"><meta name="author" content="Thomas Belin"><link rel="canonical" href="https://blog.atomrc.dev/p/git-reflog/"><meta property="og:title" content="Recovering lost commits with git reflog - Thomas Belin"><meta property="og:description" content="Any move you make in a git repository is recorded by git. Let's use this to our advantage and never lose a commit again!"><meta property="og:url" content="https://blog.atomrc.dev/p/git-reflog/"><meta property="og:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@atomrc"><meta name="twitter:title" content="Recovering lost commits with git reflog - Thomas Belin"><meta name="twitter:description" content="Any move you make in a git repository is recorded by git. Let's use this to our advantage and never lose a commit again!"><meta name="twitter:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc"><meta name="color-scheme" content="dark light"><style>body{--ff-sans:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI","Ubuntu","Roboto","Noto Sans","Droid Sans",sans-serif;--ff-mono:ui-monospace,"Cascadia Mono","Segoe UI Mono","Ubuntu Mono","Roboto Mono",Menlo,Monaco,Consolas,monospace;padding:0;margin:0;color:var(--font-color);background-color:var(--bg-color);font-family:var(--ff-sans);font-size:13pt}body,body.light-mode{--font-color:#333;--font-secondary-color:#555;--bg-color:#fff;--title-color:#e7005d;--link-color:#0e4db5;--bg-code-color:#f6f6f6;--secondary-color:#eee}body.dark-mode{--font-color:#ddd;--font-secondary-color:#aaa;--bg-color:#1c1c21;--title-color:var(--link-color);--link-color:rgb(88, 166, 255);--bg-code-color:#444;--secondary-color:#333}#dark-mode-toggle{border:none;background-color:transparent;position:fixed;top:1em;right:1em;z-index:1;height:24px;width:24px;overflow:hidden}#dark-mode-toggle svg{stroke:var(--font-color);fill:var(--font-color);transition:opacity .3s,fill .3s,stroke .3s;position:absolute;top:0;left:0}.dark-mode #dark-mode-toggle .moon,.light-mode #dark-mode-toggle .sun{opacity:0}a{text-decoration:none;color:var(--link-color)}ul{list-style:none;padding:0}.avatar{height:100px;width:100px;border-radius:50px}.title{color:var(--title-color)}.title a{color:inherit}.list-title{font-size:1.2em;font-weight:400;margin:.1em}aside{padding-left:.5em;font-size:.8em}#header{text-align:center;font-size:1.95em;padding:1em}#header nav{text-align:center;margin-top:.6em;font-size:.5em}#header .title{color:var(--font-color);font-weight:200}footer{text-align:center;padding:2em}.love{color:red}footer a{color:inherit;text-decoration:underline}.list-container{max-width:50%;margin:auto;text-align:center}@media screen and (max-width:1000px){.list-container{max-width:75%}}@media screen and (max-width:650px){.list-container{max-width:80%}}.list-container__title{text-align:center}.list-container__list li{padding-bottom:.5em}.list-container__headline{max-width:500px}.list-container__content{display:inline-block;text-align:left}</style><script async defer="defer" data-domain="atomrc.dev" src="https://plausible.io/js/plausible.js"></script></head><body><button id="dark-mode-toggle" aria-label="Toggle bewteen dark and light mode"><svg xmlns="http://www.w3.org/2000/svg" class="sun" stroke-linejoin="round" stroke-linecap="round" stroke-width="2" stroke="#000" fill="none" height="24" width="24"><circle r="5" cy="12" cx="12"/><path d="M12 1v2m0 18v2M4.22 4.22l1.42 1.42m12.72 12.72 1.42 1.42M1 12h2m18 0h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg><svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" class="moon"><path style="stroke-width:.0469517" d="M13.278 24.02c3.707 0 7.093-1.687 9.336-4.451a.564.564 0 0 0-.543-.909c-5.831 1.111-11.186-3.36-11.186-9.247a9.41 9.41 0 0 1 4.765-8.188.564.564 0 0 0-.176-1.044 12.12 12.12 0 0 0-2.196-.2C6.643-.02 1.258 5.356 1.258 12c0 6.635 5.376 12.02 12.02 12.02z"/></svg></button><script>(function (win, doc) {
  let isDarkMode =
    sessionStorage.getItem("darkmode") === undefined
      ? win.matchMedia("(prefers-color-scheme: dark)").matches
      : sessionStorage.getItem("darkmode") === "true";

  const toggleDarkMode = (setDarkMode) => {
    isDarkMode = setDarkMode ?? !isDarkMode;
    sessionStorage.setItem("darkmode", isDarkMode);
    if (isDarkMode) {
      document.body.classList.add("dark-mode");
      document.body.classList.remove("light-mode");
    } else {
      document.body.classList.remove("dark-mode");
      document.body.classList.add("light-mode");
    }
  };

  toggleDarkMode(isDarkMode);
  const darkModeToggle = doc.getElementById("dark-mode-toggle");

  darkModeToggle.addEventListener("click", () => toggleDarkMode());
})(window, document);</script><section id="header"><div><a href="/"><img class="avatar" src="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=200" alt="Avatar"></a><br><a class="title" href="/"><span rel="author">Thomas Belin</span></a><br></div><nav><a href="/about/">About Me</a></nav></section><section><link href="/css/article.css" rel="stylesheet" async defer="defer"><link href="/css/syntax.css" rel="stylesheet" async defer="defer"><style>article{max-width:800px;margin:auto;padding:0 1em;position:relative;line-height:1.5em}article h1{font-size:2em;font-weight:300;line-height:1em}article h2,article h3{position:relative;padding-bottom:.3em;font-weight:500;line-height:1.2em}article h2{font-size:2em;border-bottom:solid 1px var(--secondary-color);margin:1em 0 .5em}article h3{font-size:1.5em;margin:1em 1em}article ul{list-style-type:disc;padding:0 2em}article picture{border:solid 1px grey;display:block;max-width:100%;margin:auto}picture img,video{width:100%;height:auto}</style><article lang="en"><header><h1 class="title">Recovering lost commits with git reflog</h1><aside>üè∑Ô∏è <span class="tag">posts</span>&nbsp; <span class="tag">git</span>&nbsp; <span class="tag">cli</span>&nbsp;<br><time datetime="" pubdate itemprop="datePublished" content="">üìÜ 04&nbsp;Dec&nbsp;22</time></aside></header><div class="article-body"><p>Once familiar with <code>git</code>, editing code becomes a breeze. Refactorings and deletions feel as natural and safe as adding code. <code>git</code> is always there to back us up if something goes awfully wrong!</p><p>But what about <strong>editing the git history itself?</strong><br>Could someone also have our back when we run <code>rebase</code> or <code>reset</code>?</p><p>The answer is &quot;yes&quot;! <code>git</code> has just the right for this job: the <code>reflog</code>!</p><p>Once you have built your own mental model of <code>reflog</code>, history-modifying commands become as natural and safe as editing code.</p><p>Before we actually dive in into what <code>reflog</code> is, we need to understand a key concept in <code>git</code>: the <code>HEAD</code>.</p><h2 id="what-is-head%3F" tabindex="-1">What is <code>HEAD</code>?</h2><p>The <code>HEAD</code> in <code>git</code> is a simple pointer of the commit that is currently checked out in your local work tree.</p><p>When digging a little further into the core of git, you realize that <strong>pretty much anything is a reference to a commit in git</strong>. <code>branches</code>, <code>HEAD</code>, <code>stash</code> are all commit references.</p><p>A look into the <code>.git/refs</code> folder will reveal all those references:</p><ul><li><code>.git/refs/heads/&lt;branchname&gt;</code> ‚Üí points to the latest commit of the branch <code>&lt;branchname&gt;</code></li><li><code>.git/refs/stash</code> ‚Üí points to the latest commit on the <code>stash</code> (yes, the changes you stash are commits under the hood)</li><li><code>.git/refs/tags/&lt;tagname&gt;</code> ‚Üí points to the commit referenced by the tag <code>&lt;tagname&gt;</code></li></ul><p>Along with it, you will find 2 more special commit references in the <code>.git/</code> folder</p><ul><li><code>.git/HEAD</code> ‚Üí the reference of the commit that is currently checked out in your local repository</li><li><code>.git/ORIG_HEAD</code> ‚Üí the reference of the previous position of the HEAD (somewhat deprecated, <code>reflog</code> achieves the same goal and much more)</li></ul><h2 id="what-is-the-reflog%3F" tabindex="-1">What is the <code>reflog</code>?</h2><p>The <code>reflog</code> is a quite simple concept, actually! It is a <strong>log of all the moves the git <code>HEAD</code> has ever made</strong> in your local repository.</p><p>As such, <code>reflog</code> is a very personal log that will never be shared with the remote repository. You will share the same commit history with your coworkers (modulus the commits that are not pushed) but your <code>reflog</code> is <em>yours only</em>.</p><h2 id="which-commands-are-moving-the-head%3F" tabindex="-1">Which commands are moving the <code>HEAD</code>?</h2><p>The rule of thumb is: if you move from one commit to another, then the <code>HEAD</code> is changing and a new¬†entry is appended to the <code>reflog</code>.<br>To be slightly more exhaustive, let's explain a few git commands with regard to what it does to the <code>HEAD</code>:</p><ul><li><code>git commit</code> ‚Üí creates a new commit and moves the <code>HEAD</code> to this commit</li><li><code>git checkout &lt;branch&gt;</code> ‚Üí moves the <code>HEAD</code> from its current commit to the commit referenced by <code>&lt;branch&gt;</code></li><li><code>git pull</code> ‚Üí pulls the missing commits from the remote and moves the <code>HEAD</code> to the latest commit</li><li><code>git merge</code> ‚Üí creates a merge commit and moves <code>HEAD</code> to point to this merge commit</li><li><code>git reset HEAD~1</code> ‚Üí moves the <code>HEAD</code> to the previous commit</li><li>...</li></ul><p>Every single of those moves will be inserted into the <code>reflog</code>.</p><figure>¬†<video controls alt="git reflog in action">¬† ¬†<source src="https://i.imgur.com/sPAWe6v.mp4" type="video/mp4">¬†</video>¬†<figcaption>On the left, you see some git commands being executed. On the right is the live <code>reflog</code></figcaption></figure><p>Let's take a simple example in order to let the concept sink in.<br>Imagine you are on branch <code>feature</code> and this is the initial state of the history:</p><pre class="language-text"><code class="language-text">A initial commit &lt; <i>(HEAD, feature)</i></code></pre><p>Let's run a bunch of <code>git</code> commands on top of it</p><p><code>git commit -m 'second commit'</code>: moves <code>HEAD</code> and <code>feature</code> to the newly created commit</p><pre class="language-text"><code class="language-text">B second commit &lt; <i>(HEAD, feature)</i>
|
A initial commit</code></pre><p><code>git checkout A</code>: moves <code>HEAD</code> to commit <code>A</code> (but <code>feature</code> is still pointing to <code>B</code>)</p><pre class="language-text"><code class="language-text">B second commit &lt; <i>(feature)</i>
|
A initial commit &lt; <i>(HEAD)</i></code></pre><p><code>git checkout feature</code>: moves <code>HEAD</code> back to the commit referenced by <code>feature</code></p><pre class="language-text"><code class="language-text">B second commit &lt; <i>(HEAD, feature)</i>
|
A initial commit</code></pre><p><code>git reset A</code>: moves both <code>HEAD</code> and <code>feature</code> to commit <code>A</code></p><pre class="language-text"><code class="language-text">B second commit
|
A initial commit &lt; <i>(HEAD, feature)</i></code></pre><p>Every single of those moves will be recorded in the <code>reflog</code>.</p><h2 id="real-life-example%3A-recovering-from-a-reset" tabindex="-1">Real life example: recovering from a <code>reset</code></h2><p>Let's say you ran the examples commands that we saw earlier. You are in that state</p><pre class="language-text"><code class="language-text">B
|
A &lt; <i>(HEAD, feature)</i></code></pre><p>Both <code>HEAD</code> and <code>feature</code> are pointing to <code>A</code> and you might feel that commit <code>B</code> is lost forever.</p><p>Fear not, commit <code>B</code> is all but lost. It has just become <strong>unreachable</strong> from the branches you have... But it still exists in <code>git</code>!</p><p>Unfortunately, commit hashes usually do not look like <code>A</code> but more something like <code>f1fec78c3a05708d7cb55d9e213f1ac51292b52f</code>. ¬† This makes it impossible, for a human at least, to just recall that hash and run <code>git reset &lt;commithash&gt;</code>.</p><p>That's where the <code>reflog</code> comes into play.</p><p>As we said earlier, every single move you make between commits is recorded in the <code>reflog</code>. ¬† So, let's have a look at that <code>reflog</code>:</p><pre class="language-text"><code class="language-text">A HEAD@{0}: reset: moving to A
B HEAD@{1}: checkout: moving from A to feature
A HEAD@{2}: checkout: moving from feature to A
B HEAD@{3}: commit: second commit</code></pre><p>The entire story of what happened in the previous example is just lying there. We can see everything we did in reverse chronology order (the most recent moves on the top). We can reconstruct the story just by reading this log from bottom to top. ¬† Most importantly, we now have the commit hash that we are interested in recovering: <code>B</code>.</p><p>So we have a few options to recover our commit:</p><pre class="language-sh"><code class="language-sh"><span class="token function">git</span> reset B <span class="token comment"># reseting our current branch to the commit hash we want</span>
<span class="token function">git</span> reset HEAD@<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span> <span class="token comment"># reset our current branch to the previous state of `HEAD`</span>
<span class="token function">git</span> cherry-pick B <span class="token comment"># create a new commit on top of `feature` with the content of commit `B`</span>
<span class="token comment"># last option is only if there is a single commit you want to recover</span></code></pre><p>Recovering from a failed <code>rebase</code> is pretty much similar.<br>It is just a matter of finding the previous top commit of the branch in the <code>reflog</code> and running <code>git reset &lt;previous-top-commit-hash&gt;</code>. You will find all the initial commits <strong>exactly as they were before the rebase was initiated</strong>.</p><h2 id="conclusion" tabindex="-1">Conclusion</h2><p>One thing you can keep in mind is: <strong>There are no lost commits in git, only harder-to-reach ones!</strong> Once something is committed to <code>git</code>, it is here to stay! A hard-to-reach commit is just a <code>git reflog</code> away!</p><p>So, do not fear playing with <code>reset</code> or <code>rebase</code> in your feature branches and enjoy confident history rewritings* ü§ì! <strong>Git is here to back you up!</strong></p><p>*But please in mind that rewriting history of branches shared with coworkers is never a good idea ;)</p></div><br><em>You enjoyed this article? Consider <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/intent/tweet?url=https://blog.atomrc.dev/p/git-reflog/&text=Recovering lost commits with git reflog&via=atomrc">tweeting it</a> :)</em></article><script src="/js/posts.js" async></script><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebSite",
      "@id": "https://blog.atomrc.dev#website",
      "url": "https://blog.atomrc.dev",
      "name": "Thomas Belin",
      "description": "Freelance Front-End Architect in Paris. I leave code cleaner than I found it. Seriously into Functional and Reactive Programming.",
      "inLanguage": "en"
    },
    {
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.atomrc.dev/p/git-reflog/"
      },
      "url": "https://blog.atomrc.dev/p/git-reflog/",
      "isPartOf": {
        "@id": "https://blog.atomrc.dev#website"
      },
      "headline": "Recovering lost commits with git reflog",
      "description": "Any move you make in a git repository is recorded by git. Let's use this to our advantage and never lose a commit again!",
      "image": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
      "inLanguage": "en",
      "publisher": {
        "@type": "Organization",
        "name": "Thomas Belin",
        "url": "https://blog.atomrc.dev#organization",
        "logo": {
          "@type": "ImageObject",
          "url": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
          "width": 300,
          "height": 300
        }
      },
      "author": {
        "@type": "Person",
        "name": "Thomas Belin"
      },
      "keywords": "posts,git,cli",
      "datePublished": "2022-12-04T00:00:00.000Z"
    }
  ]
}</script></section><footer>Made with <span class="love">‚ô•</span>Ô∏è by <a href="https://twitter.com/atomrc" rel="noopener noreferrer">@atomrc</a><br><a href="/feed.xml">RSS feed</a></footer></body></html>