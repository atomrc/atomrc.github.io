<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="alternate" type="application/rss+xml" title="Thomas Belin's Blog" href="https://blog.atomrc.dev/feed.xml"><link rel="icon" href="/favicon.ico"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><title>Le guide que j&apos;aurais aim&eacute; avoir quand j&apos;ai commenc&eacute; Flux - Thomas Belin</title><meta name="description" content="Commencer Flux avec la doc officielle n&apos;est pas forcement facile, voila une petite synth&egrave;se des grandes id&eacute;es et concepts de Flux"><meta name="robots" content="index,follow"><meta name="author" content="Thomas Belin"><link rel="canonical" href="https://blog.atomrc.dev/p/react-flux/"><meta property="og:title" content="Le guide que j&apos;aurais aim&eacute; avoir quand j&apos;ai commenc&eacute; Flux - Thomas Belin"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.atomrc.dev/p/react-flux/"><meta property="og:description" content="Commencer Flux avec la doc officielle n&apos;est pas forcement facile, voila une petite synth&egrave;se des grandes id&eacute;es et concepts de Flux"><meta property="og:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@atomrc"><meta name="twitter:url" content="https://blog.atomrc.dev/p/react-flux/"><meta name="twitter:title" content="Le guide que j&apos;aurais aim&eacute; avoir quand j&apos;ai commenc&eacute; Flux - Thomas Belin"><meta name="twitter:description" content="Commencer Flux avec la doc officielle n&apos;est pas forcement facile, voila une petite synth&egrave;se des grandes id&eacute;es et concepts de Flux"><meta name="twitter:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300"><meta name="theme-color" content="#ffffff"><style>body{--ff-sans:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI","Ubuntu","Roboto","Noto Sans","Droid Sans",sans-serif;--ff-mono:ui-monospace,"Cascadia Mono","Segoe UI Mono","Ubuntu Mono","Roboto Mono",Menlo,Monaco,Consolas,monospace;padding:0;margin:0;color:#333;background-color:#fff;font-family:var(--ff-sans);font-size:13pt}a{text-decoration:none;color:#0e4db5}ul{list-style:none;padding:0}.avatar{height:100px;width:100px;border-radius:50px}.title{color:#e7005d}.tag{font-size:10pt;color:#555;font-style:italic}#header{text-align:center;font-size:1.95em;padding:1em}#header .title{text-shadow:1px 1px 0 #fff;color:inherit;font-weight:200}#footer{text-align:center;padding:2em}.love{color:red}#footer a{color:inherit;text-decoration:underline}</style><script async defer="defer" data-domain="atomrc.dev" src="https://plausible.io/js/plausible.js"></script></head><body><div id="header"><div><a href="/"><img class="avatar" src="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=200" alt="Avatar"></a><br><a class="title" href="/"><span rel="author">Thomas Belin</span></a><br></div></div><section><link href="/css/article.css" rel="stylesheet" async defer="defer"><link href="/css/syntax.css" rel="stylesheet" async defer="defer"><style>article{max-width:800px;margin:auto;padding:0 1em;position:relative;line-height:1.5em}article h1{font-size:2em;font-weight:300}article h2,article h3{position:relative;padding-bottom:.3em;font-weight:500}article h2{font-size:2em;border-bottom:solid 1px #eee;margin:1em 0 .5em}article h3{font-size:1.5em;margin:1em 2em}article ul{list-style-type:disc;padding:0 2em}article img{border:solid 1px grey;display:block;max-width:90%;margin:auto}</style><article lang="fr"><header><h1 class="title">Le guide que j'aurais aimé avoir quand j'ai commencé Flux</h1><aside><time class="folded-paper" datetime="Mon Oct 19 2015 00:00:00 GMT+0000 (Coordinated Universal Time)" pubdate itemprop="datePublished" content="Mon Oct 19 2015 00:00:00 GMT+0000 (Coordinated Universal Time)">19 <span class="month">Oct</span> 2015</time><br><span class="tag">posts</span>&nbsp; <span class="tag">ReactJS</span>&nbsp; <span class="tag">Flux</span>&nbsp;</aside></header><div class="article-body"><p>En commençant <a href="https://facebook.github.io/flux/docs/overview.html#content">Flux</a>, j'avoue avoir eu beaucoup de moments de confusion et questions inutiles qui me sont venus à l'esprit. La majorité des questions que je me posais venaient de la confusion qu'il est facile de faire entre la <a href="https://facebook.github.io/flux/docs/overview.html#content">présentation de Flux</a> et le <a href="https://github.com/facebook/flux">Github de Flux</a>.</p><p>Je vous propose donc de revenir un peu sur la source de ma confusion puis de reprendre, avec les idées au clair, les concepts de Flux emsemble.</p><h2 id="pourquoi-j'ai-%C3%A9t%C3%A9-confus-par-flux" tabindex="-1">Pourquoi j'ai été confus par Flux</h2><p>La majeure partie de ma confusion venait du fait que je n'avais pas bien compris de quoi la doc traitait.<br>Le souci c'est qu'une partie de la doc parle du concept de Flux en montrant des exemple de code (c'est le cas du sempiternel exemple de la TODO list) alors que d'autres parties de la doc parlent de l'<a href="https://facebook.github.io/flux/docs/dispatcher.html#content">implémentation que Facebook utilise</a> et dont on trouve le code sur Github.</p><p>Je n'arrivais pas à voir que Flux n'était pas un framework ni une librairie mais juste un concept. Aussi je prenais la doc comme si c'était la documentation de leur <a href="https://github.com/facebook/flux">implémentation de Flux</a>, or pas uniquement. Seulement, quand vous lisez cette doc dans cet état d'esprit, vous voyez des incohérences partout et vous finissez par vous enerver.</p><p>Du coup, pour lire la suite de cet article mettez vous bien en tête que :</p><ul><li>Flux n'est pas du code mais un concept ;</li><li>les exemples de code ici n'utilisent aucune implémentation de Flux particulière.</li></ul><p>Sachez qu'il existe un grand nombre d'implémentations de Flux qui se baladent avec de solides documentations. Je vous invite à consulter ce site qui vous montrera un peu les tendances d'utilisation des différentes implémentations : <a href="https://github.com/kriasoft/react-starter-kit/issues/22">Which Flux implementation should I use?</a>.</p><h2 id="le-probl%C3%A8me-que-r%C3%A9sout-flux" tabindex="-1">le problème que résout Flux</h2><p>Dans le modèle MVC classique, vous avez votre modèle (les données brutes) vos contrôleurs (qui passent les données aux vues et qui récupèrent les actions des vues pour mettre à jour le modèle) et vos vues (qui s'occupent simplement d'afficher les donnés calculées dans un template et d'envoyer des évènements aux contrôleurs). Le souci de ce schéma est que vos contrôleurs font beaucoup trop de choses dans votre application. Les vrais problèmes commencent à apparaitre quand vous commencez à avoir un contrôleur qui gère un type de données et plusieurs vues qui affichent cette même donnée.</p><p>La <a href="https://www.youtube.com/watch?list=PLb0IAmt7-GS188xDYE-u1ShQmFFGbrk0v&amp;v=nYkdrAPrdcw#t=621">petite histoire que raconte Facebook</a> pour expliquer le problème que résout Flux parle du chat.<br>La première version n'est qu'un petit panel en bas de page, c'est tout. À ce moment là, c'est simplement un petit composant MVC et dispose de son contrôleur. Ce contrôleur s'occupe de recevoir les messages et récupère les évènements du panel pour envoyer les messages. Si on devait écrire, de façon très synthétique, la méthode de contrôleur qui gère les nouveaux messages on aurait sûrement quelque chose comme ça :</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> chatPanel <span class="token operator">=</span> <span class="token function">getChatPanel</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    chatPanel<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Puis est arrivé le bandeau de notification en <em>topbar</em> de Facebook, celle-ci indique (entre autres) le nombre de messages non lus dans le chat. Le code du contrôleur se complexifie alors un peu pour devenir.</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> chatPanel <span class="token operator">=</span> <span class="token function">getChatPanel</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    chatPanel<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    chatNotif<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>chatPanel<span class="token punctuation">.</span><span class="token function">hasFocus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">//si le chat a le focus, on peut décrémenter la notif</span><br>        chatNotif<span class="token punctuation">.</span><span class="token function">decrease</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Enfin est arrivé la page de chat dédiée, sur laquelle les deux précédents composants peuvent bien sûr être présents. Notre nouveau code ressemble maintenant à :</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> chatPanel <span class="token operator">=</span> <span class="token function">getChatPanel</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    chatPanel<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    chatNotif<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>chatPage<span class="token punctuation">.</span>currentThread <span class="token operator">===</span> message<span class="token punctuation">.</span>thread<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">//si la page de chat est ouverte sur la conversation</span><br>        <span class="token comment">//on ajoute le message</span><br>        chatPage<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>chatPanel<span class="token punctuation">.</span><span class="token function">hasFocus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> chatPage<span class="token punctuation">.</span>currentThread <span class="token operator">===</span> message<span class="token punctuation">.</span>thread<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        chatNotif<span class="token punctuation">.</span><span class="token function">decrease</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Bon je pense que vous voyez l'idée, plus on rajoute de vues associées à ces données, plus on va rendre nos contrôleurs complexes. Ce qui veut dire un code plus dur à maintenir et à comprendre.<br>Notez que vous avez aussi à traiter tous les événements qui peuvent être liés à cette messagerie (focus sur chacune des vues et quand l'utilisateur répond par exemple).</p><p>Le problème de fond est : <strong>le contrôleur est responsable de beaucoup trop de choses</strong></p><p>Flux répond à ça en deux points assez simples :</p><ul><li>un <strong>flux d'actions unidirectionnel</strong> ;</li><li>la fin de la séparation des vues et contrôleurs au profit de <strong>controller-views</strong> responsables de transformer les données qu'ils affichent.</li></ul><h2 id="flux" tabindex="-1">Flux</h2><p>La principale idée de flux est de faire passer le moindre évènement de votre application au travers d'une boucle qui va parcourir tous vos stores (les éléments qui contiennent les données de votre application, nous reviendrons dessus juste après).<br>Si vous allez voire le <a href="https://github.com/facebook/flux/tree/master/src">code de Flux</a> vous vous rendrez compte qu'il ne se compose en fait que d'un dispatcher (et de quelques helpers). Car en réalité <strong>Flux n'est pas du code mais plutôt une nouvelle façon de penser son code</strong>.</p><p>Avec Flux votre codebase va se décomposer de la façon suivante :</p><ul><li>des <strong>stores</strong> qui sont l'endroit où votre modèle va être contenu ;</li><li>des <strong>actions</strong> qui représente toutes les choses que votre appli peut faire ;</li><li>un (et un seul) <strong>dispatcher</strong> qui notifie les stores des actions effectuées ;</li><li>des <strong>controller-views</strong> qui vont transformer et afficher les données qu'on leur donne.</li></ul><h3 id="les-stores" tabindex="-1">Les stores</h3><p>C'est ici que tout vos modèles vont vivre. Les stores sont en fait une représentation complète de l'état, à un instant <code>t</code>, de votre application. Il ne doit y avoir <strong>aucun de vos modèles qui vit en dehors d'un store</strong>.<br>Si vous vous pliez à cette règle, il vous suffira de faire une sauvegarde des données de vos stores et la recharger plus tard pour pouvoir retrouver l'application dans l'état exact dans laquelle vous l'aviez laissée.</p><p>Les stores se comportent comme un modèle observable (il dispose de getters et d'une méthode addListener) à la différence près qu'<strong>il n'a pas de setter</strong>. Et cela nous mène à une autre idée très importante dans Flux : <strong>seul le store peut mettre à jour ses propres données</strong></p><p>À ce stade vous vous demandez donc normalement comment faire pour pouvoir changer l'état de l'application si on a aucun setter dans notre entité qui contient tous les modèles de l'application. C'est à ce moment là que le <strong>dispatcher</strong> entre en jeux.</p><h3 id="le-dispatcher" tabindex="-1">Le dispatcher</h3><p>Le dispatcher est là pour faire transiter <strong>absolument tout ce qu'il se passe sur l'application par vos stores</strong>. Quand je parle de tout ce qui se passe, je parle bien sûr des évènements. Les évènements c'est par exemple :</p><ul><li>« l'utilisateur a cliqué sur le bouton de suppression »</li><li>« l'utilisateur a soumit tel formulaire »</li><li>mais aussi « le serveur a envoyé telle donnée »</li><li>ou encore « le serveur a indiqué que les identifiants de connexion sont faux ».</li></ul><p>Bref, quand je dis tout ce qu'il se passe, c'est tout.</p><p>Dans le bootstrap de votre application tous vos stores devront donc être enregistrés auprès de ce dispatcher unique qui les préviendra alors dès qu'il se passe quelque chose sur l'applications.<br>Le dispatcher est là pour crier bêtement à tous les stores « hey les gars il s'est passé ceci, faites en ce que vous en voulez ». Son rôle s'arrête là.</p><p>Par la suite, vos stores eux choisissent de réagir, ou non, aux évènements qu'ils reçoivent. Pour ça, votre store va donner un <em>callback</em> à votre dispatcher qui sera appelé à chaque évènement. Souvent ce callback sera composé d'un switch qui va traiter uniquement les cas qui l’intéresse.</p><p>Allez, un peu de concret avec un petit bout de code pour illustrer tout ça. Imaginons un store qui garde bien au chaud en mémoire une liste de ... TODOS (et merde, je m'étais juré que je ne prendrais pas cet exemple … :/ )</p><p>On dispose d'un côté d'une liste d'évènements sous forme de constantes</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> events <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token comment">//quand l'application reçoit une liste de todos du serveur (ou d'ailleurs)</span><br>    <span class="token constant">RECEIVED_TODOS</span><span class="token operator">:</span> <span class="token string">"RECEIVED_TODOS"</span><span class="token punctuation">,</span><br><br>    <span class="token comment">//quand l'utilisateur ajoute un nouveau todo</span><br>    <span class="token constant">TODO_ADDED</span><span class="token operator">:</span> <span class="token string">"TODO_ADDED"</span><span class="token punctuation">,</span><br><br>    <span class="token comment">//quand les todos ont été sauvegardés sur le serveur</span><br>    <span class="token constant">TODOS_SAVED</span><span class="token operator">:</span> <span class="token string">"TODOS_SAVED"</span><br>    <span class="token comment">//[...] plein d'autres évènements que nous ne traiterons pas ici</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> events<span class="token punctuation">;</span></code></pre><p>et de notre store qui gère les todos :</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment">//l'instance unique de notre dispatcher de l'application</span><br><span class="token keyword">var</span> appDispatcher <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"../dispatcher/appDispatcher"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token comment">//les évènements définis précédemment</span><br>    events <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./events"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">//nos todos. inaccessibles depuis l'extérieur et vide pour le moment</span><br><span class="token comment">//c'est une action qui viendra remplir tout ça</span><br><span class="token keyword">var</span> todos <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br><span class="token keyword">var</span> TodosStore <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token comment">//l'unique méthode accessible depuis l'extérieur</span><br>    <span class="token comment">//qui nous retourne simplement les todos</span><br>    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> todos<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">//ps il faut rajouter ici les méthodes d'ajout/suppresion</span><br>    <span class="token comment">//d'event listeners (addListener/removeListener)</span><br>    <span class="token comment">//qui serviront pour prévenir les vues que quelque chose</span><br>    <span class="token comment">//a changé</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">//c'est ici que la magie s’opère. On enregistre un callback qui sera appelé dès que quelque chose se passe</span><br>appDispatcher<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">//dans le payload on a tous les détails de l'évènement (type et données qui va avec)</span><br>    <span class="token keyword">var</span> action <span class="token operator">=</span> payload<span class="token punctuation">.</span>actionType<span class="token punctuation">,</span><br>        data <span class="token operator">=</span> payload<span class="token punctuation">.</span>data<span class="token punctuation">;</span><br><br>    <span class="token comment">//on répond uniquement aux évènements qui nous intéressent</span><br>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">//quand on reçoit les todos, on remplace simplement nos todos</span><br>        <span class="token comment">//par les todos reçus</span><br>        <span class="token keyword">case</span> events<span class="token punctuation">.</span><span class="token constant">RECEIVED_TODOS</span><span class="token operator">:</span><br>            todos <span class="token operator">=</span> data<span class="token punctuation">.</span>todos<span class="token punctuation">;</span><br>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emitChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//stay tuned, on parle de ça bientôt</span><br>            <span class="token keyword">break</span><span class="token punctuation">;</span><br><br>        <span class="token comment">//quand un todo est créé sur le serveur on l'ajoute dans notre </span><br>        <span class="token comment">//liste de todos</span><br>        <span class="token keyword">case</span> events<span class="token punctuation">.</span><span class="token constant">TODO_ADDED</span><span class="token operator">:</span><br>            todos<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>todo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//on ajoute la nouvelle todo dans la liste</span><br>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emitChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//stay tuned, on parle de ça bientôt</span><br>            <span class="token keyword">break</span><span class="token punctuation">;</span><br><br>        <span class="token comment">//par défaut, on ne fait rien</span><br>        <span class="token comment">//vous noterez par exemple qu'on ne répond pas ici </span><br>        <span class="token comment">//à l'évènement TODOS_SAVED car il n'aurait aucune influence</span><br>        <span class="token comment">//sur les données brute de ce store</span><br>        <span class="token keyword">default</span><span class="token operator">:</span><br>            <span class="token keyword">break</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>todosStore<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> todosStore<span class="token punctuation">;</span></code></pre><p>Ça y est nous avons de quoi stocker nos données dans l'application mais rien ni pour les afficher ni pour les remplir. Je vous propose donc de parler des vues avant de finir sur les actions.</p><h3 id="les-vues" tabindex="-1">Les vues</h3><p>Allez maintenant qu'on sait comment stocker nos données, voyons un peu comment les afficher. Pour ça, on va utiliser les controller-views.<br>L'idée principale du controller-view est de regrouper ensemble le contrôleur et sa vue associée. Ainsi on se débarrasse d'une partie du problème qu'introduit Facebook avec son chat : <strong>le contrôleur responsable de beaucoup de vues</strong>.<br>Facebook distingue tout de même deux type de vues différentes dans Flux : les views simples et les containers.</p><p>Dans la suite de ce paragraphe, je vais considérer qu'on utilise <a href="https://facebook.github.io/react/docs/getting-started.html">React</a> pour faire nos vues, et que vous avez une connaissance des <a href="https://facebook.github.io/react/docs/getting-started.html">concepts de base de React</a>. Sachez que rien ne vous oblige à utiliser React pour vos vues.</p><h4 id="les-containers" tabindex="-1">les containers</h4><p>Les containers sont des controller-views un peu spéciaux : ils écoutent les changements d'un store.<br>L'idée du container est de centraliser les données relatives à une partie de votre application à un seul endroit. Le container passera ensuite ces données à ses enfants pour affichage.<br>Pour reprendre le cas de notre application de TODOS on va avoir envie d'avoir un container qui à accès à l'utilisateur loggé et un autre qui s'occupe des TODOS. Ils écouteront respectivement les <code>userStore</code> et <code>todosStore</code>.</p><p>Vous l’aviez peut-être vu dans le callback passé au dispatcher dans mon exemple précédent, on voit le todosStore appeler la méthode <code>emitChange</code>. En réalité, c’est cette méthode qui va permettre aux stores de prévenir les vues que des choses ont changées chez eux. Aussi quand vous créez un nouveau container, vous devez enregistrer un callback auprès des stores dont il dépend (et ne pas oublier de le détruire quand le composant est détruit). Avec React on fait ça dans le <code>componentWillMount</code> ce qui nous donne</p><pre class="language-javascript"><code class="language-javascript">React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>    <span class="token comment">//...</span><br>    <span class="token function-variable function">componentWillMount</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>         <span class="token comment">// à la création du composant, on enregistre le listener</span><br>         userStore<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>onChange<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br><br>    <span class="token function-variable function">componentWillUnmount</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>         <span class="token comment">// à la suppression du composant, on retire le listener</span><br>        userStore<span class="token punctuation">.</span><span class="token function">removeListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>onChange<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br><br>    <span class="token comment">//ce callback est appelé à chaque fois que le userStore change</span><br>    <span class="token function-variable function">onChange</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>            <span class="token literal-property property">user</span><span class="token operator">:</span> userStore<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br><br>    <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">//on a ici la dernière valeur du user</span><br>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>App user<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>user<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Comme son nom l'indique, le container ne fait que contenir des données. Et, à ce titre, comme vous pouvez le voir dans le code précédent, la méthode <code>render</code> est la plus simple possible. Elle délègue simplement le rendu à un composant de vue … Et c’est tout !</p><p>Ainsi, vos container ne sont responsables que d'une seule chose : mettre à jour les données pour tout le reste des composants. On respecte bien le fameux <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsability Principle</a> et le débug ne s'en porte que mieux.</p><h4 id="les-controller-views" tabindex="-1">Les controller-views</h4><p>Les controller-views ne sont là que pour transformer vos données brutes et les afficher comme vous le voulez. Il reçoivent donc toutes leurs données via des propriétés et sont censés être complètement <em>stateless</em>.<br>On retrouve, avec les vues, un concept propre à la programmation fonctionnelle : une fonction retournera toujours le même résultat si on lui donne les mêmes paramètres. On appelle ça les <a href="https://fr.wikipedia.org/wiki/Fonction_pure">fonctions pures</a>.<br>D'ailleurs avec la <a href="https://facebook.github.io/react/blog/2015/09/10/react-v0.14-rc1.html#changelog">nouvelle syntaxe de composant</a> que React v0.14 a introduit récemment, vous pouvez déclarer un composant comme étant une simple fonction qui prend en paramètre des <code>props</code> et retourne du JSX. Avec cette syntaxe, pas de <code>state</code> et on est alors obligé de faire un composant <em>stateless</em>.</p><p>Pour reprendre notre application de TODOS qu'on a commencé plus tôt, voila à quoi pourrait ressembler notre composant <code>App</code> :</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">App</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> user <span class="token operator">=</span> props<span class="token punctuation">.</span>user<span class="token punctuation">;</span><br>    <span class="token keyword">return</span> <span class="token punctuation">(</span><br>        <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"header"</span><span class="token operator">></span><br>            <span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>firstname<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><br>            <span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>lastname<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><br>            <span class="token operator">&lt;</span>LogoutButton user<span class="token operator">=</span><span class="token punctuation">{</span>user<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><br>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><br>        <span class="token operator">&lt;</span>TodoContainer <span class="token operator">/</span><span class="token operator">></span><br>    <span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Note : les composant-fonctions sont les composants les plus simples qu'on puisse trouver. Pas d'event handler dedans, de mixin ni de réécriture de <a href="https://facebook.github.io/react/docs/component-specs.html#lifecycle-methods">méthode du cycle de vie du composant</a> (comme <code>componentWillMount</code> par exemple). Ne vous sentez donc pas obligé de n'utiliser que des composant-fonctions. Utilisez les dès que vous pouvez.</p><h3 id="les-actions" tabindex="-1">Les actions</h3><p>Ok si on récapitule on a donc les vues qui récupèrent leurs données depuis les stores qui eux modifient leurs données selon les informations du dispatcher, la question qui réside est : qui donc fait appel au dispatcher ? La réponse est, bien sûr, les actions.</p><p>C'est dans les actions que la magie opère. C'est elles qui sont à l'origine de tout ce qui peut changer l'état de l'application (ajout/suppression/édition d'un TODO, récupérations des TODOs sur le serveur ...).<br>Les actions sont donc les éléments qui vont utiliser le dispatcher pour lancer des évènements que les stores vont interpréter.</p><p>Le code des actions est souvent très simple. Je vais distinguer deux types d'actions :</p><ul><li>les actions qui n'ont d'effets que sur les données locales qui sont souvent synchrones ;</li><li>les actions qui ont un effets sur des données externes (typiquement qui viennent d'une API) qui sont souvent asynchrones.</li></ul><p>Le premier type d'action est vraiment très simple, il ne fait qu'appeler le dispatcher un point c'est tout.<br>Considérons ce scénario d'ajout de TODO :</p><ul><li>l'utilisateur édite son TODO tout frais ;</li><li>quand il a fini, il ajoute son TODO dans la liste ;</li><li>il peut en ajouter plein d'autres ;</li><li>une fois qu'il est content de sa liste de TODOs il peut la sauvegarder sur le serveur.</li></ul><p>Dans ce scénario, il y a les deux type d'actions dont je vous ai parlé.</p><ul><li><code>addTodo</code> qui ajoute en local un nouveau TODO ;</li><li><code>saveTodos</code> qui prend tous les nouveaux TODOs et les sauvegarde via une requête AJAX sur le serveur.</li></ul><p>si on voulait implémenter ces deux actions, ça nous donnerait quelque chose comme ça :</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> todoActions <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token function-variable function">addTodo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">todo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">//"Bon allez ça ça part chez les stores qui savent quoi faire de ce truc"</span><br>        dispatcher<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>            <span class="token literal-property property">actionType</span><span class="token operator">:</span> <span class="token string">"TODO_ADDED"</span><span class="token punctuation">,</span><br>            <span class="token literal-property property">todo</span><span class="token operator">:</span> todo<br>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token comment">//my job here is done</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br><br>    <span class="token function-variable function">saveTodos</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">todos</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">//"OK j'envoie ça au serveur et ensuite je file ça aux stores</span><br>        api<br>            <span class="token punctuation">.</span><span class="token function">saveTodos</span><span class="token punctuation">(</span>todos<span class="token punctuation">)</span><br>            <span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>                <span class="token comment">//OK c'est bon les enfants</span><br>                dispatcher<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>                    <span class="token literal-property property">actionType</span><span class="token operator">:</span> <span class="token string">"TODOS_SAVED"</span><span class="token punctuation">,</span><br>                    <span class="token literal-property property">todos</span><span class="token operator">:</span> response<span class="token punctuation">.</span>todos<br>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token punctuation">}</span><span class="token punctuation">)</span><br>            <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>                <span class="token comment">//oh merde les gars ça a pas marché</span><br>                dispatcher<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>                    <span class="token literal-property property">actionType</span><span class="token operator">:</span> <span class="token string">"TODOS_SAVE_FAILED"</span><span class="token punctuation">,</span><br>                    <span class="token literal-property property">todos</span><span class="token operator">:</span> todos<br>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Notez que les évènements dispatchés par les actions décrivent des <strong>choses qui se sont passées</strong> et pas ce que doit faire l'application par rapport à cette action. Pour illustrer mon propos voila un exemple qu'on pourrait être tenté de faire.<br>Prenons le cas où la sauvegarde sur le serveur s'est mal passée (donc on passe dans le <code>catch</code>), on pourrait avoir envie de dispatcher un <code>&quot;SHOW_NOTIFICATION_TODOS_SAVE_FAIL&quot;</code>. En faisant ça, on donne à l'action une connaissance de ce que l'application peut faire.<br>Or une action ne doit faire que constater ce qu'il se passe et le transmettre.</p><h3 id="flux-en-r%C3%A9sum%C3%A9" tabindex="-1">Flux en résumé</h3><p>Pour résumer un peu voila les idées qui sortent de Flux :</p><ul><li>les stores contiennent toutes les données brutes de l'app ;</li><li>les stores représentent l'état de l'application à l'instant <code>t</code> et sont donc complètement synchrone ;</li><li>seuls les stores peuvent modifier leurs données ;</li><li>les stores réagissent aux évènements du dispatcher ;</li><li>les stores sont comme un modèle observable mais sans <code>setter</code> ;</li><li>les vues écoutent les changements d'un (ou plusieurs) store(s) et se rendent en fonction ;</li><li>une vue qui est reliée à un store est appelée &quot;container&quot; et doit avoir une méthode <code>render</code> simplissime ;</li><li>le dispatcher est les yeux des stores vis à vis de l'application (il dit au stores tout ce qu'il se passe) ;</li><li>les actions sont là pour appeler le dispatcher et éventuellement des services externes (API, localStorage ...) ;</li><li>pour nommer un évènement que doit dispatcher une action il faut se poser la question « Que vient-il de se passer dans mon application ? » et pas « Que devrait faire mon application face à ça ? »</li></ul><p>Et le petit graphique qui résume très bien les interactions entre les composants :</p><p><img src="https://raw.githubusercontent.com/facebook/flux/master/docs/img/flux-diagram-white-background.png" alt="Flux illustrated"></p><p>(ps: Pourquoi ce schéma n'apparait que sur le github et nulle part sur la doc alors qu'il résume bien mieux Flux que les schéma qu'on peut trouver <a href="http://facebook.github.io/flux/docs/overview.html#content">ici</a>)</p><p>On pourrait représenter une application Flux comme une fonction qui prend en paramètre un état à un instant <code>t</code> et une action et qui retourne l'état à l'état <code>t+1</code> :</p><pre><code>application(state1, action) =&gt; state2
</code></pre><p>Si on considère que cette fonction est <a href="https://fr.wikipedia.org/wiki/Fonction_pure">pure</a> (qu'elle ne fait que retourner un nouvel état sans rien modifier en mémoire pour faire simple), alors tous les états de cette application sont déterministes (une même action ne pourra pas donner deux résultats différents) et vous pouvez par exemple facilement mettre en oeuvre du <em>undo/redo</em> (la <a href="http://rackt.org/redux/docs/recipes/ImplementingUndoHistory.html">doc de Redux</a> explique ça très bien).</p><h2 id="conclusion" tabindex="-1">Conclusion</h2><p>Je trouve l'idée qu'a eu Facebook d'implémenter le concept de Flux entièrement dans sa doc très bonne. C'est un peu comme ces articles qui réimplémente une techno populaire (eg. <a href="http://teropa.info/blog/2013/11/03/make-your-own-angular-part-1-scopes-and-digest.html">Make your own Angular</a>) pour l'expliquer. C'est très didactique et permet de vraiment comprendre ce qu'il se passe <em>sous la capuche</em> (comme disent les américains) des outils qu'on utilise tous les jours (ou presque).<br>En revanche je trouve dommage qu'ils n'aient pas plus séparé le concept et l'implémentation dans leur doc. Je reconnais avec le recul que j'aurais pu comprendre ça plus tôt. Je suis surement parti trop vite dans le code sans lire à fond le concept d'abord, mais je pense que je ne suis pas le seul à avoir pris ce chemin.</p><p>Outre ça, le concept de Flux est génial et a vraiment changé ma façon de faire mes applications.<br>Alors si je peux vous donner un conseil, c'est trouvez vous une implémentation de Flux qui vous va (ou faites la vous même) et lancez vous :)</p></div><br><em>You enjoyed this article? Consider <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/intent/tweet?url=https://blog.atomrc.dev/p/react-flux/&text=Le guide que j'aurais aimé avoir quand j'ai commencé Flux&via=atomrc">tweeting it</a> :)</em></article><script src="/js/application.js" async></script><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebSite",
      "@id": "https://blog.atomrc.dev#website",
      "url": "https://blog.atomrc.dev",
      "name": "Thomas Belin",
      "description": "Freelance Front-End Architect in Paris. I leave code cleaner than I found it. Seriously into Functional and Reactive Programming.",
      "inLanguage": "fr"
    },
    {
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.atomrc.dev/p/react-flux/"
      },
      "url": "https://blog.atomrc.dev/p/react-flux/",
      "isPartOf": {
        "@id": "https://blog.atomrc.dev#website"
      },
      "headline": "Le guide que j'aurais aimé avoir quand j'ai commencé Flux",
      "description": "Commencer Flux avec la doc officielle n'est pas forcement facile, voila une petite synthèse des grandes idées et concepts de Flux",
      "image": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
      "inLanguage": "fr",
      "publisher": {
        "@type": "Organization",
        "name": "Thomas Belin",
        "url": "https://blog.atomrc.dev",
        "logo": {
          "@type": "ImageObject",
          "url": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
          "width": 300,
          "height": 300
        }
      },
      "author": {
        "@type": "Person",
        "name": "Thomas Belin"
      },
      "keywords": "posts,ReactJS,Flux",
      "datePublished": "2015-10-19T00:00:00.000Z"
    }
  ]
}</script></section><div id="footer">Made with <span class="love">♥</span>️ by <a href="https://twitter.com/atomrc" rel="noopener noreferrer">@atomrc</a></div></body></html>