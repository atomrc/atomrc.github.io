<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="alternate" type="application/rss+xml" title="Thomas Belin's Blog" href="https://blog.atomrc.dev/feed.xml"><link rel="icon" href="/favicon.ico"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><title>Inspiring from React's useEffect to design effective APIs: the cleanup function pattern - Thomas Belin</title><meta name="description" content="Let's inspire from React's useEffect pattern to design easy-to-use and encapsulated effectful APIs"><meta name="author" content="Thomas Belin"><link rel="canonical" href="https://blog.atomrc.dev/p/cleanup-function-pattern/"><meta property="og:title" content="Inspiring from React's useEffect to design effective APIs: the cleanup function pattern - Thomas Belin"><meta property="og:description" content="Let's inspire from React's useEffect pattern to design easy-to-use and encapsulated effectful APIs"><meta property="og:url" content="https://blog.atomrc.dev/p/cleanup-function-pattern/"><meta property="og:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@atomrc"><meta name="twitter:title" content="Inspiring from React's useEffect to design effective APIs: the cleanup function pattern - Thomas Belin"><meta name="twitter:description" content="Let's inspire from React's useEffect pattern to design easy-to-use and encapsulated effectful APIs"><meta name="twitter:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc"><meta name="color-scheme" content="dark light"><style>body{--ff-sans:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI","Ubuntu","Roboto","Noto Sans","Droid Sans",sans-serif;--ff-mono:ui-monospace,"Cascadia Mono","Segoe UI Mono","Ubuntu Mono","Roboto Mono",Menlo,Monaco,Consolas,monospace;padding:0;margin:0;color:var(--font-color);background-color:var(--bg-color);font-family:var(--ff-sans);font-size:13pt}body,body.light-mode{--font-color:#333;--font-secondary-color:#555;--bg-color:#fff;--title-color:#e7005d;--link-color:#0e4db5;--bg-code-color:#f6f6f6;--secondary-color:#eee}body.dark-mode{--font-color:#ddd;--font-secondary-color:#aaa;--bg-color:#1c1c21;--title-color:var(--link-color);--link-color:rgb(88, 166, 255);--bg-code-color:#444;--secondary-color:#333}#dark-mode-toggle{border:none;background-color:transparent;position:fixed;top:1em;right:1em;z-index:1;height:24px;width:24px;overflow:hidden}#dark-mode-toggle svg{stroke:var(--font-color);fill:var(--font-color);transition:opacity .3s,fill .3s,stroke .3s;position:absolute;top:0;left:0}.dark-mode #dark-mode-toggle .moon,.light-mode #dark-mode-toggle .sun{opacity:0}a{text-decoration:none;color:var(--link-color)}ul{list-style:none;padding:0}.avatar{height:100px;width:100px;border-radius:50px}.title{color:var(--title-color)}.title a{color:inherit}.list-title{font-size:1.2em;font-weight:400;margin:.1em}aside{padding-left:.5em;font-size:.8em}#header{text-align:center;font-size:1.95em;padding:1em}#header nav{text-align:center;margin-top:.6em;font-size:.5em}#header .title{color:var(--font-color);font-weight:200}footer{text-align:center;padding:2em}.love{color:red}footer a{color:inherit;text-decoration:underline}.list-container{max-width:50%;margin:auto;text-align:center}@media screen and (max-width:1000px){.list-container{max-width:75%}}@media screen and (max-width:650px){.list-container{max-width:80%}}.list-container__title{text-align:center}.list-container__list li{padding-bottom:.5em}.list-container__headline{max-width:500px}.list-container__content{display:inline-block;text-align:left}</style><script async defer="defer" data-domain="atomrc.dev" src="https://plausible.io/js/plausible.js"></script></head><body><button id="dark-mode-toggle" aria-label="Toggle bewteen dark and light mode"><svg xmlns="http://www.w3.org/2000/svg" class="sun" stroke-linejoin="round" stroke-linecap="round" stroke-width="2" stroke="#000" fill="none" height="24" width="24"><circle r="5" cy="12" cx="12"/><path d="M12 1v2m0 18v2M4.22 4.22l1.42 1.42m12.72 12.72 1.42 1.42M1 12h2m18 0h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg><svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" class="moon"><path style="stroke-width:.0469517" d="M13.278 24.02c3.707 0 7.093-1.687 9.336-4.451a.564.564 0 0 0-.543-.909c-5.831 1.111-11.186-3.36-11.186-9.247a9.41 9.41 0 0 1 4.765-8.188.564.564 0 0 0-.176-1.044 12.12 12.12 0 0 0-2.196-.2C6.643-.02 1.258 5.356 1.258 12c0 6.635 5.376 12.02 12.02 12.02z"/></svg></button><script>(function (win, doc) {
  let isDarkMode =
    sessionStorage.getItem("darkmode") === undefined
      ? win.matchMedia("(prefers-color-scheme: dark)").matches
      : sessionStorage.getItem("darkmode") === "true";

  const toggleDarkMode = (setDarkMode) => {
    isDarkMode = setDarkMode ?? !isDarkMode;
    sessionStorage.setItem("darkmode", isDarkMode);
    if (isDarkMode) {
      document.body.classList.add("dark-mode");
      document.body.classList.remove("light-mode");
    } else {
      document.body.classList.remove("dark-mode");
      document.body.classList.add("light-mode");
    }
  };

  toggleDarkMode(isDarkMode);
  const darkModeToggle = doc.getElementById("dark-mode-toggle");

  darkModeToggle.addEventListener("click", () => toggleDarkMode());
})(window, document);</script><section id="header"><div><a href="/"><img class="avatar" src="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=200" alt="Avatar"></a><br><a class="title" href="/"><span rel="author">Thomas Belin</span></a><br></div><nav><a href="/about/">About Me</a></nav></section><section><link href="/css/article.css" rel="stylesheet" async defer="defer"><link href="/css/syntax.css" rel="stylesheet" async defer="defer"><style>article{max-width:800px;margin:auto;padding:0 1em;position:relative;line-height:1.5em}article h1{font-size:2em;font-weight:300;line-height:1em}article h2,article h3{position:relative;padding-bottom:.3em;font-weight:500;line-height:1.2em}article h2{font-size:2em;border-bottom:solid 1px var(--secondary-color);margin:1em 0 .5em}article h3{font-size:1.5em;margin:1em 1em}article ul{list-style-type:disc;padding:0 2em}article picture{border:solid 1px grey;display:block;max-width:100%;margin:auto}picture img,video{width:100%;height:auto}</style><article lang="en"><header><h1 class="title">Inspiring from React's useEffect to design effective APIs: the cleanup function pattern</h1><aside>üè∑Ô∏è <span class="tag">posts</span>&nbsp; <span class="tag">javascript</span>&nbsp; <span class="tag">reactive programming</span>&nbsp; <span class="tag">rxjs</span>&nbsp; <span class="tag">react</span>&nbsp; <span class="tag">useEffect</span>&nbsp;<br><time datetime="2022-12-24T00:00:00.000Z" pubdate itemprop="datePublished" content="2022-12-24T00:00:00.000Z">üìÜ 24&nbsp;Dec&nbsp;22</time></aside></header><div class="article-body"><p>React's <code>useEffect</code> forces you to implement a quite powerful pattern: the <strong>cleanup function pattern</strong> (or teardown function pattern).</p><p>Let's see how we could leverage this pattern to provide <strong>perfect encapsulation</strong> and make <strong>deceptive calls impossible</strong>.</p><h2 id="the-cleanup-function-pattern" tabindex="-1">The cleanup function pattern</h2><p>The idea is quite simple: A function that triggers a long-lived side effect returns another function to teardown this effect.</p><p>The pattern goes as follows:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// trigger some long lived effect (listening to a websocket, registering DOM event listeners...)</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">cleanupEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// cleanup the long lived effect</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>React developers will immediately recognize the <a href="https://reactjs.org/docs/hooks-effect.html#example-using-hooks-1"><code>useEffect</code></a> pattern.</p><pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// trigger some long lived effect</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// cleanup</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This pattern is not so fancy nor new! It has been around in Reactive Programming libraries for a little while. RxJS' <a href="https://rxjs.dev/guide/subscription"><code>subscribe</code> method</a> follows this pattern, for example.<br>The main difference between React and RxJS (or others), is that <strong>RxJS implements the cleanup function pattern</strong> while <strong>React requires you to implement the pattern</strong>.</p><h2 id="benefits-of-the-cleanup-function-pattern" tabindex="-1">Benefits of the cleanup function pattern</h2><p>There are two main takeaways to this pattern:</p><ul><li>it brings <strong>perfect encapsulation</strong>;</li><li>it makes <strong>deceptive calls impossible</strong>.</li></ul><p>Let's take a very common API that could benefit from the cleanup function pattern: the famous <code>(add|remove)EventListener</code> DOM API.</p><p>A traditional usage of this API would look something like this:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">sendPayload</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"the-button"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> sendPayload<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ... later on</span>
button<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> sendPayload<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>How about we try to implement our own <code>addListener</code> function that implements the cleanup function pattern?</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">addListener</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> event<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    element<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><h3 id="perfect-encapsulation" tabindex="-1">Perfect encapsulation</h3><p>One of the problems of the <code>button.addEventListener</code> is that you <strong>need to keep track</strong> of the DOM element (<code>button</code>), the event name (<code>click</code>) and the callback (<code>sendPayload</code>) in order to be able to remove this listener.<br>Lose one of those ingredients, and your <code>click</code> listener is here to stay!</p><p>Thanks to our custom <code>addListener</code> function that we implemented earlier, a <strong>single reference</strong> is needed in order to remove the listener:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">sendPayload</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"the-button"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> removeListener <span class="token operator">=</span> <span class="token function">addListener</span><span class="token punctuation">(</span>button<span class="token punctuation">,</span> <span class="token string">"click"</span><span class="token punctuation">,</span> sendPayload<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//    ^ removeListener is the only reference we need to keep</span>
<span class="token function">removeListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Now, the references to the button, the event name and the callback are <strong>encapsulated in the cleanup function</strong>. The only thing we need to keep track of is the <code>removeListener</code> function.</p><p>So we could even inline everything</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> removeListener <span class="token operator">=</span> <span class="token function">addListener</span><span class="token punctuation">(</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"the-button"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token string">"click"</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>‚ö†Ô∏è <em>I <strong>would not</strong> suggest inlining code like the previous code sample. This example is there just to highlight that it is possible.</em></p></blockquote><h3 id="preventing-deceptive-calls" tabindex="-1">Preventing deceptive calls</h3><p>Let's consider the following samples:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">sendPayload</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

button<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> sendPayload<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ‚ùå Useless call, the listener has not been added yet (temporal coupling)</span>

button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> sendPayload<span class="token punctuation">)</span><span class="token punctuation">;</span>

button<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">sendPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ‚ùå The listener is not removed because the reference to the function has changed</span>

button<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">"auxclick"</span><span class="token punctuation">,</span> sendPayload<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ‚ùå this is useless since we never added a `auxclick` listener</span></code></pre><p>Some of those calls are not only useless, they are deceptive. You could <em>feel like you have removed the listener</em>, but in fact it's still there and active.</p><p>Those calls are made impossible with the cleanup function pattern!</p><p>If you do not have the reference to the <code>cleanupFunction</code> that you first created by triggering the effect, there is nothing you can do!<br>We are preventing what is called a <a href="https://betterprogramming.pub/temporal-coupling-in-code-e74899f7a48f">temporal coupling</a>.</p><h2 id="a-concrete-example%3A-listening-to-a-websocket" tabindex="-1">A concrete example: Listening to a WebSocket</h2><p>Let's implement a naive module that subscribes to WebSocket events and forwards them to the consumer:</p><pre class="language-js"><code class="language-js"><span class="token keyword">let</span> ws<span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token parameter">onEvent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">"wss://example.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  ws<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> onEvent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ws<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ws<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ws <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>A few things to note:</p><ul><li>the <code>close</code> function can be called even if the connection is not active;</li><li>the module needs to be stateful and keep track of <code>ws</code>;</li><li>we need to perform some checks before we can safely close (<code>if (ws)</code>);</li><li>if we call <code>listen</code> multiple times there will be instances that cannot be killed anymore, the reference to <code>ws</code> is lost forever.</li></ul><p>Now, with our newly discovered pattern</p><pre class="language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token parameter">onEvent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">"wss://example.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  ws<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> onEvent<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    ws<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>With the added benefit that the code is now more concise, everything is isolated, this module doesn't need to keep a local state, and you just cannot <code>close</code> until you have actually opened the connection.</p><h2 id="conclusion" tabindex="-1">Conclusion</h2><p>Next time you are dealing with a long-lived effect, try to play with the idea of returning the function that will kill the effect, and see how it works for you.</p><p>I lately implemented it for <a href="https://github.com/wireapp/wire-web-packages/blob/eebabf50943170b87f1c8aa6d8cbf4527e9a9238/packages/core/src/Account.ts#L677-L681">Wire's webapp connection to the WebSocket</a>, and I am totally sold üöÄ</p></div><br><em>You enjoyed this article? Consider <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/intent/tweet?url=https://blog.atomrc.dev/p/cleanup-function-pattern/&text=Inspiring from React's useEffect to design effective APIs: the cleanup function pattern&via=atomrc">tweeting it</a> :)</em></article><script src="/js/posts.js" async></script><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebSite",
      "@id": "https://blog.atomrc.dev#website",
      "url": "https://blog.atomrc.dev",
      "name": "Thomas Belin",
      "description": "Freelance Front-End Architect in Paris. I leave code cleaner than I found it. Seriously into Functional and Reactive Programming.",
      "inLanguage": "en"
    },
    {
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.atomrc.dev/p/cleanup-function-pattern/"
      },
      "url": "https://blog.atomrc.dev/p/cleanup-function-pattern/",
      "isPartOf": {
        "@id": "https://blog.atomrc.dev#website"
      },
      "headline": "Inspiring from React's useEffect to design effective APIs: the cleanup function pattern",
      "description": "Let's inspire from React's useEffect pattern to design easy-to-use and encapsulated effectful APIs",
      "image": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
      "inLanguage": "en",
      "publisher": {
        "@type": "Organization",
        "name": "Thomas Belin",
        "url": "https://blog.atomrc.dev#organization",
        "logo": {
          "@type": "ImageObject",
          "url": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
          "width": 300,
          "height": 300
        }
      },
      "author": {
        "@type": "Person",
        "name": "Thomas Belin"
      },
      "keywords": "posts,javascript,reactive programming,rxjs,react,useEffect",
      "datePublished": "2022-12-24T00:00:00.000Z"
    }
  ]
}</script></section><footer>Made with <span class="love">‚ô•</span>Ô∏è by <a href="https://twitter.com/atomrc" rel="noopener noreferrer">@atomrc</a><br><a href="/feed.xml">RSS feed</a></footer></body></html>