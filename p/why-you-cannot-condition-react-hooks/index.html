<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="alternate" type="application/rss+xml" title="Thomas Belin's Blog" href="https://blog.atomrc.dev/feed.xml"><link rel="icon" href="/favicon.ico"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><title>Why React Hooks cannot be conditioned - Thomas Belin</title><meta name="description" content="Did you know that you cannot condition React Hooks? Here is the reason why"><meta name="robots" content="index,follow"><meta name="author" content="Thomas Belin"><link rel="canonical" href="https://blog.atomrc.dev/p/why-you-cannot-condition-react-hooks/"><meta property="og:title" content="Why React Hooks cannot be conditioned - Thomas Belin"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.atomrc.dev/p/why-you-cannot-condition-react-hooks/"><meta property="og:description" content="Did you know that you cannot condition React Hooks? Here is the reason why"><meta property="og:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@atomrc"><meta name="twitter:url" content="https://blog.atomrc.dev/p/why-you-cannot-condition-react-hooks/"><meta name="twitter:title" content="Why React Hooks cannot be conditioned - Thomas Belin"><meta name="twitter:description" content="Did you know that you cannot condition React Hooks? Here is the reason why"><meta name="twitter:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300"><meta name="theme-color" content="#ffffff"><style>body{--ff-sans:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI","Ubuntu","Roboto","Noto Sans","Droid Sans",sans-serif;--ff-mono:ui-monospace,"Cascadia Mono","Segoe UI Mono","Ubuntu Mono","Roboto Mono",Menlo,Monaco,Consolas,monospace;padding:0;margin:0;color:#333;background-color:#fff;font-family:var(--ff-sans);font-size:13pt}a{text-decoration:none;color:#0e4db5}ul{list-style:none;padding:0}.avatar{height:100px;width:100px;border-radius:50px}.title{color:#e7005d}.tag{font-size:10pt;color:#555;font-style:italic}#header{text-align:center;font-size:1.95em;padding:1em}#header .title{text-shadow:1px 1px 0 #fff;color:inherit;font-weight:200}#footer{text-align:center;padding:2em}.love{color:red}#footer a{color:inherit;text-decoration:underline}</style><script async defer="defer" data-domain="atomrc.dev" src="https://plausible.io/js/plausible.js"></script></head><body><div id="header"><div><a href="/"><img class="avatar" src="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=200" alt="Avatar"></a><br><a class="title" href="/"><span rel="author">Thomas Belin</span></a><br></div></div><section><link href="/css/article.css" rel="stylesheet" async defer="defer"><link href="/css/syntax.css" rel="stylesheet" async defer="defer"><style>article{max-width:800px;margin:auto;padding:0 1em;position:relative;line-height:1.5em}article h1{font-size:2em;font-weight:300}article h2,article h3{position:relative;padding-bottom:.3em;font-weight:500}article h2{font-size:2em;border-bottom:solid 1px #eee;margin:1em 0 .5em}article h3{font-size:1.5em;margin:1em 2em}article ul{list-style-type:disc;padding:0 2em}article img{border:solid 1px grey;display:block;max-width:90%;margin:auto}</style><article lang="en"><header><h1 class="title">Why React Hooks cannot be conditioned</h1><aside><time class="folded-paper" datetime="Sun May 30 2021 00:00:00 GMT+0000 (Coordinated Universal Time)" pubdate itemprop="datePublished" content="Sun May 30 2021 00:00:00 GMT+0000 (Coordinated Universal Time)">30 <span class="month">May</span> 2021</time><br><span class="tag">posts</span>&nbsp; <span class="tag">react</span>&nbsp; <span class="tag">react-hooks</span>&nbsp; <span class="tag">api-design</span>&nbsp;</aside></header><div class="article-body"><p>If you've used <a href="https://reactjs.org/docs/hooks-intro.html">React hooks</a> along with the <a href="https://github.com/facebook/react/tree/master/packages/eslint-plugin-react-hooks"><code>eslint-plugin-react-hooks</code></a>, you might have encountered the unexpected warning <code>React Hook &quot;useState&quot; is called conditionally.</code>.<br>One can be quite surprised by this warning. At least I was.</p><p>Back then I had already seen a similar pattern with <a href="https://knockoutjs.com/"><code>knockoutjs</code></a> and I though it was a pretty bad design flaw. I was puzzled a modern tool, like React, would allow for such a weakness.</p><p>So I decided to investigate and deep dive into how React Hooks work and why they cannot be conditioned.</p><h2 id="tldr" tabindex="-1">TLDR</h2><ul><li>the hook system is a quite big stateful machine that records every call to any hook (<code>useEffect</code>, <code>useState</code> ...);</li><li>at component's mount time <strong>all</strong> React hooks must be called so that they are registered against the hook system;</li><li>the order at which React hooks are called in a component must be stable through time and renders.</li></ul><h2 id="disclaimer" tabindex="-1">Disclaimer</h2><p>I ran my investigations against React <code>v17</code>. Other versions might work differently (I am pretty sure it does not).</p><p>Also bear in mind that the code you are going to see in the article is not actual code from the React codebase. It's my own interpretation of what I read in there. The names of variables and functions have been changed for the sake of simplicity.</p><h2 id="what-happens-when-a-hook-function-is-called" tabindex="-1">What happens when a hook function is called</h2><p>Hook functions (<code>useState</code>, <code>useEffect</code>, ...) are rather interesting functions in that they are stateful at two levels:</p><ul><li>They mutate values in a global state;</li><li>Depending when, in the component's lifecyle, they are called (<code>mount</code>, <code>update</code>, ...) they do not run the same code.</li></ul><h3 id="at-mount-time" tabindex="-1">At mount time</h3><p>Let's take a very simple component as a working example:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> setFirst<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>second<span class="token punctuation">,</span> setSecond<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token comment">/*...*/</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>When <code>React</code> mounts this component, it will create a state that is associated with the instance of the component. In this state it will store, among other things, a linked list of all the hooks that have been called during the mounting of the component.</p><p>So when <code>React</code> executes <code>Component()</code> any call to a <code>use*</code> function will create an entry in the linked list and we will end up with a state that looks like this:</p><pre class="language-js"><code class="language-js"><span class="token punctuation">{</span><br>  <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">"first"</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">next</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">"second"</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">next</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// End of the linked list</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Around a component initialisation, in React, we have code that looks like this:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// global variable that will be mutated by each and every use* call</span><br>  global<span class="token punctuation">.</span>currentComponentHooks <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br>  <span class="token comment">// keeps track of the last hook that was mounted</span><br>  global<span class="token punctuation">.</span>lastMountedHook <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">const</span> children <span class="token operator">=</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// [...]</span><br><span class="token punctuation">}</span></code></pre><p>If we try to guess the body of the <code>useState</code> (<code>useEffect</code> would be, somewhat, similar) it should look something like:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// Creates the new entry</span><br>  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token literal-property property">value</span><span class="token operator">:</span> value<span class="token punctuation">,</span><br>    <span class="token literal-property property">next</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>global<span class="token punctuation">.</span>currentComponentHooks <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// If it is the first entry, stores it in the global object</span><br>    global<span class="token punctuation">.</span>currentComponentHooks <span class="token operator">=</span> hook<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Add the current hook to the `next` property</span><br>    global<span class="token punctuation">.</span>lastMountedHook<span class="token punctuation">.</span>next <span class="token operator">=</span> hook<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token comment">// Keep track that this hook is the last one we mounted</span><br>  global<span class="token punctuation">.</span>lastMountedHook <span class="token operator">=</span> hook<span class="token punctuation">;</span><br>  <span class="token comment">// [...]</span><br>  <span class="token keyword">return</span> <span class="token punctuation">[</span>value<span class="token punctuation">,</span> updateState<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// finally returns the initial value plus an update function</span><br><span class="token punctuation">}</span></code></pre><p>With the component we had earlier this is what the <code>global.currentComponentHooks</code> will look like as lines are executed:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// null</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> setFirst<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// {value 'first', next: null}</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>second<span class="token punctuation">,</span> setSecond<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// {value 'first', next: {value: 'second', next: null}}</span><br>  <span class="token keyword">return</span> <span class="token comment">/*...*/</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h3 id="at-update-time" tabindex="-1">At update time</h3><p>Let's imagine something happened on the UI level and <code>setFirst('updated')</code> was called.</p><p><em>I am not going to describe how the <code>setFirst</code> function behaves. Just bear in mind that it is bound to the relevant entry in the linked list and simply mutates the <code>value</code> property. It then triggers a re-rendering on React's side.</em></p><p>At mount time we have stacked our different hooks in a linked list. At update time we are going to traverse our linked list and read each stored value.</p><p>On React's side we need to create a pointer that will point to the root of our linked list before we re-render our component.</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  global<span class="token punctuation">.</span>currentHook <span class="token operator">=</span> global<span class="token punctuation">.</span>currentComponentHooks<span class="token punctuation">;</span> <span class="token comment">// {value 'first', next: {value: 'second', next: null}}</span><br>  <span class="token keyword">const</span> children <span class="token operator">=</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// global.currentHook === null</span><br><span class="token punctuation">}</span></code></pre><p>It means that the body of the <code>useState</code> function must have changed.</p><pre class="language-js"><code class="language-js"><span class="token comment">/* note that we do not need the initial value anymore */</span><br><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token comment">/*value*/</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> hook <span class="token operator">=</span> global<span class="token punctuation">.</span>currentHook<span class="token punctuation">;</span><br>  global<span class="token punctuation">.</span>currentHook <span class="token operator">=</span> hook<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// we move the pointer to the next hook</span><br>  <span class="token comment">// [...]</span><br>  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>value<span class="token punctuation">,</span> updateState<span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>And from our component's context this is how the <code>currentHook</code> pointer evolves.</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// {value 'updated', next: {value: 'second', next: null}}</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> setFirst<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// first === 'updated' our mutated state</span><br>  <span class="token comment">// {value 'second', next: null}</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>second<span class="token punctuation">,</span> setSecond<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// second === 'second' the unchanged initial state</span><br>  <span class="token keyword">return</span> <span class="token comment">/*...*/</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h2 id="so...-why-can't-we-condition-a-hook%3F" tabindex="-1">So... Why can't we condition a hook?</h2><p>Now that we have seen the internals of how hooks work, let's see what would happen if we conditioned one of them. A (arguably!) valid scenario for conditioning a hook would probably be triggering an <code>effect</code> depending on some props. (Note that, just like <code>useState</code>, <code>useEffect</code> are also added the the linked list of all the hooks of a component)</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>doEffect<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> setFirst<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>doEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token comment">/*...*/</span><span class="token punctuation">)</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>second<span class="token punctuation">,</span> setSecond<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Now let's say that the component will mount with <code>{doEffect: false}</code>. We will end up with that linked list:</p><p><code>{value: 0, next: {value: 0, next: null}}</code></p><p>We only have two elements and the <code>useEffect</code> does not exist in our list.</p><p>If ever <code>doEffect</code> switches to <code>true</code> we will now try to access a hook that was not registered</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> doEffect <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// {value: 0, next: {value: 0, next: null}}</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> setFirst<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>doEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// {value: 0, next: null}</span><br>    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token comment">/*...*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ⚠️ Wrong hook here</span><br>  <span class="token punctuation">}</span><br>  <span class="token comment">// null</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>second<span class="token punctuation">,</span> setSecond<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ⚠️ No hook left!!</span><br><span class="token punctuation">}</span></code></pre><p>In order to fix this, we just need to move our condition inside the body of the <code>useEffect</code> hook (and not forget to add it in the dependency of the <code>useEffect</code>)</p><pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>doEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Do your magic</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>doEffect<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="conclusion" tabindex="-1">Conclusion</h2><p>React Hooks have quite changed how we write React apps. As a React user, I find being able to write only functional components (as opposed to class components) to be very pleasant!</p><p>But this comfort comes at a price:</p><ul><li>hooks feel like black magic and make the lifecycle of the component hard to grasp (and actually you should probably <a href="https://kentcdodds.com/blog/react-hooks-pitfalls#pitfall-3-thinking-in-lifecycles">not think in lifecycles</a>);</li><li>we need stricts rules regarding how hooks are called.</li></ul><p>I would also add that all those states inside the React codebase make the flow pretty hard to follow and understand. I can not thank enough my debugger for the step-by-step execution. Without it, this article would probably not exist 😅!!</p><p>Although the <code>eslint-plugin-react-hooks</code> is almost always included in any React codebase, needing a special <code>eslint</code> rule feels like a somewhat serious design flaw. That being said, and in my humble opinion, this is an acceptable tradeoff though :)</p></div><br><em>You enjoyed this article? Consider <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/intent/tweet?url=https://blog.atomrc.dev/p/why-you-cannot-condition-react-hooks/&text=Why React Hooks cannot be conditioned&via=atomrc">tweeting it</a> :)</em></article><script src="/js/application.js" async></script><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebSite",
      "@id": "https://blog.atomrc.dev#website",
      "url": "https://blog.atomrc.dev",
      "name": "Thomas Belin",
      "description": "Freelance Front-End Architect in Paris. I leave code cleaner than I found it. Seriously into Functional and Reactive Programming.",
      "inLanguage": "en"
    },
    {
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.atomrc.dev/p/why-you-cannot-condition-react-hooks/"
      },
      "url": "https://blog.atomrc.dev/p/why-you-cannot-condition-react-hooks/",
      "isPartOf": {
        "@id": "https://blog.atomrc.dev#website"
      },
      "headline": "Why React Hooks cannot be conditioned",
      "description": "Did you know that you cannot condition React Hooks? Here is the reason why",
      "image": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
      "inLanguage": "en",
      "publisher": {
        "@type": "Organization",
        "name": "Thomas Belin",
        "url": "https://blog.atomrc.dev#organization",
        "logo": {
          "@type": "ImageObject",
          "url": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
          "width": 300,
          "height": 300
        }
      },
      "author": {
        "@type": "Person",
        "name": "Thomas Belin"
      },
      "keywords": "posts,react,react-hooks,api-design",
      "datePublished": "2021-05-30T00:00:00.000Z"
    }
  ]
}</script></section><div id="footer">Made with <span class="love">♥</span>️ by <a href="https://twitter.com/atomrc" rel="noopener noreferrer">@atomrc</a></div></body></html>