<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="alternate" type="application/rss+xml" title="Thomas Belin's Blog" href="https://blog.atomrc.dev/feed.xml"><link rel="icon" href="/favicon.ico"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><title>Get to know your browser's performance profiler - Thomas Belin</title><meta name="description" content="The performance profiler can feel a little overwhelming and scary. But once you understand its basic principles it becomes the most powerful performance debugging tool"><meta name="author" content="Thomas Belin"><link rel="canonical" href="https://blog.atomrc.dev/p/js-performance-profiling/"><meta property="og:title" content="Get to know your browser's performance profiler - Thomas Belin"><meta property="og:description" content="The performance profiler can feel a little overwhelming and scary. But once you understand its basic principles it becomes the most powerful performance debugging tool"><meta property="og:url" content="https://blog.atomrc.dev/p/js-performance-profiling/"><meta property="og:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@atomrc"><meta name="twitter:title" content="Get to know your browser's performance profiler - Thomas Belin"><meta name="twitter:description" content="The performance profiler can feel a little overwhelming and scary. But once you understand its basic principles it becomes the most powerful performance debugging tool"><meta name="twitter:image" content="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc"><meta name="color-scheme" content="dark light"><style>body{--ff-sans:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI","Ubuntu","Roboto","Noto Sans","Droid Sans",sans-serif;--ff-mono:ui-monospace,"Cascadia Mono","Segoe UI Mono","Ubuntu Mono","Roboto Mono",Menlo,Monaco,Consolas,monospace;padding:0;margin:0;color:var(--font-color);background-color:var(--bg-color);font-family:var(--ff-sans);font-size:13pt}body,body.light-mode{--font-color:#333;--font-secondary-color:#555;--bg-color:#fff;--title-color:#e7005d;--link-color:#0e4db5;--bg-code-color:#f6f6f6;--secondary-color:#eee}body.dark-mode{--font-color:#ddd;--font-secondary-color:#aaa;--bg-color:#1c1c21;--title-color:var(--link-color);--link-color:rgb(88, 166, 255);--bg-code-color:#444;--secondary-color:#333}#dark-mode-toggle{border:none;background-color:transparent;position:fixed;top:1em;right:1em;z-index:1;height:24px;width:24px;overflow:hidden}#dark-mode-toggle svg{stroke:var(--font-color);fill:var(--font-color);transition:opacity .3s,fill .3s,stroke .3s;position:absolute;top:0;left:0}.dark-mode #dark-mode-toggle .moon,.light-mode #dark-mode-toggle .sun{opacity:0}a{text-decoration:none;color:var(--link-color)}ul{list-style:none;padding:0}.avatar{height:100px;width:100px;border-radius:50px}.title{color:var(--title-color)}.tag{font-size:10pt;color:var(--font-secondary-color);font-style:italic}#header{text-align:center;font-size:1.95em;padding:1em}#header .title{color:var(--font-color);font-weight:200}#footer{text-align:center;padding:2em}.love{color:red}#footer a{color:inherit;text-decoration:underline}.list-container{max-width:50%;margin:auto;text-align:center}@media screen and (max-width:1000px){.list-container{max-width:75%}}@media screen and (max-width:650px){.list-container{max-width:80%}}.list-container__title{text-align:center}.list-container__list li{display:flex;padding-bottom:.5em}.list-container__list time{text-align:right;min-width:90px}.list-container__headline{max-width:500px}.list-container__content{display:inline-block;text-align:left}</style><script async defer="defer" data-domain="atomrc.dev" src="https://plausible.io/js/plausible.js"></script></head><body><button id="dark-mode-toggle" aria-label="Toggle bewteen dark and light mode"><svg xmlns="http://www.w3.org/2000/svg" class="sun" stroke-linejoin="round" stroke-linecap="round" stroke-width="2" stroke="#000" fill="none" height="24" width="24"><circle r="5" cy="12" cx="12"/><path d="M12 1v2m0 18v2M4.22 4.22l1.42 1.42m12.72 12.72 1.42 1.42M1 12h2m18 0h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg><svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" class="moon"><path style="stroke-width:.0469517" d="M13.278 24.02c3.707 0 7.093-1.687 9.336-4.451a.564.564 0 0 0-.543-.909c-5.831 1.111-11.186-3.36-11.186-9.247a9.41 9.41 0 0 1 4.765-8.188.564.564 0 0 0-.176-1.044 12.12 12.12 0 0 0-2.196-.2C6.643-.02 1.258 5.356 1.258 12c0 6.635 5.376 12.02 12.02 12.02z"/></svg></button><script>(function (win, doc) {
  let isDarkMode =
    sessionStorage.getItem("darkmode") === undefined
      ? win.matchMedia("(prefers-color-scheme: dark)").matches
      : sessionStorage.getItem("darkmode") === "true";

  const toggleDarkMode = (setDarkMode) => {
    isDarkMode = setDarkMode ?? !isDarkMode;
    sessionStorage.setItem("darkmode", isDarkMode);
    if (isDarkMode) {
      document.body.classList.add("dark-mode");
      document.body.classList.remove("light-mode");
    } else {
      document.body.classList.remove("dark-mode");
      document.body.classList.add("light-mode");
    }
  };

  toggleDarkMode(isDarkMode);
  const darkModeToggle = doc.getElementById("dark-mode-toggle");

  darkModeToggle.addEventListener("click", () => toggleDarkMode());
})(window, document);</script><div id="header"><div><a href="/"><img class="avatar" src="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=200" alt="Avatar"></a><br><a class="title" href="/"><span rel="author">Thomas Belin</span></a><br></div></div><section><link href="/css/article.css" rel="stylesheet" async defer="defer"><link href="/css/syntax.css" rel="stylesheet" async defer="defer"><style>article{max-width:800px;margin:auto;padding:0 1em;position:relative;line-height:1.5em}article h1{font-size:2em;font-weight:300;line-height:1.2em}article h2,article h3{position:relative;padding-bottom:.3em;font-weight:500;line-height:1.2em}article h2{font-size:2em;border-bottom:solid 1px var(--secondary-color);margin:1em 0 .5em}article h3{font-size:1.5em;margin:1em 2em}article ul{list-style-type:disc;padding:0 2em}article picture{border:solid 1px grey;display:block;max-width:100%;margin:auto}picture img,video{width:100%;height:auto}</style><article lang="en"><header><h1 class="title">Get to know your browser's performance profiler</h1><aside><time class="folded-paper" datetime="2022-05-05T00:00:00.000Z" pubdate itemprop="datePublished" content="2022-05-05T00:00:00.000Z">05 <span class="month">May</span> 2022</time><br><span class="tag">posts</span>&nbsp; <span class="tag">performance</span>&nbsp; <span class="tag">javascript</span>&nbsp; <span class="tag">firefox</span>&nbsp; <span class="tag">chrome</span>&nbsp; <span class="tag">browser</span>&nbsp;</aside></header><div class="article-body"><p>At some point in your career, you might have glanced over the <code>Performance</code> tab in the devtools of your favorite browser. You eventually tried to generate a profile but probably got quickly discouraged by it. The high density of information displayed makes it a little overwhelming and somewhat scary. I have been there, I feel you!</p><p>Good news is: the learning curve is not actually that steep!!<br>Once you have grasped a few concepts it suddenly becomes your most valued tool to tackle performance bottlenecks.</p><p>This article will give you a few keys to understand how the profiler works and how to make a good use of it.<br>Let's completely forget about <code>console.log</code> and <code>console.time</code>, today we are diving into the <code>Performance Profiler</code>!</p><p><em>Side note</em>: I won't go too deep into complex scenarios here but I will eventually do a follow up article about advanced techniques.</p><h2 id="the-data-model" tabindex="-1">The data model</h2><p>The first step that I took to actually understand how the profiler works was to read the <a href="https://profiler.firefox.com/docs/#/">Mozilla documentation about their new performance profiler</a> (This is an excellent doc, go read it).</p><p>The first <em>waouh</em> effect that I had was when I got to see the data model that the profiler was using. It's actually pretty simple</p><p>In Mozilla's documentation, the data model is represented this way:</p><pre class="language-text"><code class="language-text">A A A<br>| | |<br>v v v<br>B B B<br>  |<br>  v<br>  C</code></pre><p><code>A</code>, <code>B</code> and <code>C</code> are function names and on the <code>X</code> axis we get time. By default Firefox and Chrome's profiler is configured to take a snapshot every 1ms, which means that here every column represents 1ms.</p><p>In this example that means that the stack has evolved like this over time</p><ul><li>at 0ms <code>A</code> was calling <code>B</code> and <code>B</code> was still running</li><li>at 1ms <code>B</code> was calling <code>C</code> and <code>C</code> was still running</li><li>at 2ms <code>C</code> had finished its work and we are back in <code>B</code></li><li>at 3ms the stack was empty</li></ul><p>What the profiler can deduce from this is that:</p><ul><li><code>A</code> almost instantly called <code>B</code>;</li><li>We stayed ~1ms in <code>B</code> before calling <code>C</code>;</li><li><code>C</code> took ~1ms to execute;</li><li><code>B</code> took again ~1 more ms after calling <code>C</code>;</li><li><code>A</code> ended right after calling <code>B</code></li></ul><p>with this model in mind, we can create some profile data</p><pre class="language-text"><code class="language-text">A A A A A A A A A<br>| | | | | | | | |<br>V V V V V V V V V<br>B B B B B B B B B<br>              |<br>              V<br>              C</code></pre><p><em><code>B</code> is taking a bit of time before and after calling <code>C</code>. We spent ~1ms in <code>C</code> and no time in <code>A</code></em></p><pre class="language-text"><code class="language-text">A A A A A A A A A<br>              | |<br>              V V<br>              B B<br>              |<br>              V<br>              C</code></pre><p><em><code>A</code> is taking a bit of time before calling <code>B</code>. <code>B</code> and <code>C</code> are taking ~1ms</em></p><h2 id="the-limits-of-this-model" tabindex="-1">The limits of this model</h2><p>Since the profiler is only taking 1 sample/ms, it means that a function call that takes less that 1ms has a high chance of not showing up in the generated profile.</p><p>Let's imagine the following scenario</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt; takes 0.5ms // snapshot #1</span><br>  <span class="token constant">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt; takes 0.4ms</span><br>  <span class="token constant">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt; takes 0.2ms // snapshot #2</span><br>  <span class="token constant">E</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt; takes 0.5ms</span><br><span class="token punctuation">}</span></code></pre><p>The generated profile will, most likely, look something like this</p><pre class="language-text"><code class="language-text">A A<br>| |<br>v v<br>B D</code></pre><p>There will be no mention of <code>C</code> or <code>E</code> in this profile.</p><p>But, well, we are here to debug long tasks, remember? No need to have those fast executing functions in there. We do not care about them!</p><h2 id="self-time-vs-total-time" tabindex="-1">self time vs total time</h2><p>One slightly confusing notion in the profiler is the <code>self</code> and <code>total</code> time.<br>It's actually a notion that can be quite easily understood, though.</p><p>They can be defined this way:</p><ul><li><code>self</code> is the time spent in the function itself</li><li><code>total</code> is the time spent in the function and all the children functions that it calls</li></ul><p>To get a feeling for it, here is a concrete example:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">superExpensive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1e10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token function">superExpensiveComputation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt; takes 1000ms</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1e6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// ^ takes 5ms</span><br>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p><code>main</code> will have a self time of <code>5ms</code> but a <code>total</code> time of <code>1005ms</code>.<br><code>superExpensiveComputation</code> will have a <code>total</code> and <code>self</code> time of <code>1000ms</code></p><p>The <code>total</code> time helps identify parts of the code that are problematic while <code>self</code> time allows you to narrow down your search to the function that actually requires your attention.</p><h2 id="diving-into-the-ui" tabindex="-1">Diving into the UI</h2><p>With this model in mind, the UI starts making sense. The notions we have seen earlier start to be useful to make good use of the UI.<br>I am going to focus on the Firefox's profiler here but the same concepts apply to Chrome's profiler as well.</p><p><strong>Side note</strong> This is an interactive article. When you see a <code>Try me</code> button on the page, feel free to open your <code>Performance</code> tab, start recording and click the button so you can play around with the generated profile. Note that depending on the computer you use it might freeze your browser a bit or be too fast to actually show up in the profile...</p><h3 id="identify-long-top-level-functions%3A-the-call-tree" tabindex="-1">Identify long top-level functions: The call tree</h3><p>Let's take a super simple code sample to get started. Imagine there is a button somewhere and when clicking on it, we trigger the function <code>computeNumber</code></p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">generateNumber</span><span class="token punctuation">(</span><span class="token parameter">nbIterations</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nbIterations<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    number <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> number<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">function</span> <span class="token function">computeNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">generateNumber</span><span class="token punctuation">(</span><span class="token number">1e9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p><button onclick="computeNumber()">Try me</button></p><script>function generateNumber(nbIterations) {
  let number = 0;
  for (let i = 0; i < nbIterations; i++) {
    number += Math.random();
  }
  return number;
}

function computeNumber() {
  console.log(generateNumber(1e9));
}</script><p>This is what we will get in our profiler report:</p><p><picture><source type="image/avif" srcset="/img/RTyMHzHOOp-300.avif 300w, /img/RTyMHzHOOp-600.avif 600w, /img/RTyMHzHOOp-900.avif 900w" sizes="(max-width:300px) 300px, (max-width:600px) 600px, 900px"><source type="image/jpeg" srcset="/img/RTyMHzHOOp-300.jpeg 300w, /img/RTyMHzHOOp-600.jpeg 600w, /img/RTyMHzHOOp-900.jpeg 900w" sizes="(max-width:300px) 300px, (max-width:600px) 600px, 900px"><img alt="Screenshot of the Firefox's profiler report" loading="lazy" decoding="async" src="/img/RTyMHzHOOp-300.jpeg" width="900" height="672"></picture></p><ul><li><em>[1]</em> Since the profiler is actually profiling all the Firefox's processes, we want to make sure we are just inspecting the current web app we are working on</li><li><em>[2]</em> We are web developer here, no need for the browser's internal stack traces, let's only keep JS stack traces</li><li><em>[3]</em> We clearly see that we are spending the most amount of time in the <code>generateNumber</code> function (here the function has appeared in 488 samples, which means it has run for, at least, 488ms)</li></ul><p>The call tree will allow you to quickly identify which top level functions are taking time. It's a good overview of where to start digging, but it does not help you quickly identify nested functions that have a long <code>self</code> time.</p><h3 id="identify-long-nested-functions%3A-inverting-the-call-stack" tabindex="-1">Identify long nested functions: Inverting the call stack</h3><p>Now, let's consider the following</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">computeMultipleNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> fnName <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">gen</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span> <span class="token comment">// We create a function with a random name</span><br>    <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">function </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>fnName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">() {<br>        return generateNumber(1e7);<br>      } return </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>fnName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    number <span class="token operator">+=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  result<span class="token punctuation">.</span>innerText <span class="token operator">=</span> number<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p><button onclick="computeMultipleNumbers()">Try me</button></p><script>function computeMultipleNumbers() {
  let number = 0;
  for (let i = 0; i < 10; i++) {
    const fnName = `gen${Math.round(Math.random() * 100)}`;
    // We create a function with a random name
    const fn = new Function(`function ${fnName}() {
        return generateNumber(1e7);
      } return ${fnName}`);
    number += fn()();
  }
  console.log(number)
}</script><p>The particularity of this function is that it generates named functions with random names. Which means that now <code>generateNumber</code> will be called from many different functions.</p><p>Let's see what the profile looks like</p><p><picture><source type="image/avif" srcset="/img/w8Qlbe8CkA-300.avif 300w, /img/w8Qlbe8CkA-600.avif 600w" sizes="(max-width:300px) 300px, (max-width:600px) 600px, 900px"><source type="image/jpeg" srcset="/img/w8Qlbe8CkA-300.jpeg 300w, /img/w8Qlbe8CkA-600.jpeg 600w" sizes="(max-width:300px) 300px, (max-width:600px) 600px, 900px"><img alt="Firefox's profile screenshot for a function that calls multiple sub-functions" loading="lazy" decoding="async" src="/img/w8Qlbe8CkA-300.jpeg" width="600" height="317"></picture></p><p>Here we can see that there are many functions called, but they all have an empty <code>self</code> time. Which means this is not the function where we actually spent time, they were waiting for something else to finish.</p><p>Now, if we invert the stack.</p><video controls autplay loop>   <source src="https://i.imgur.com/SNTD2Ph.mp4" type="video/mp4"></video><p>Here it becomes clear where we actually spent time: in the <code>generateNumber</code> function :)</p><p>The inversion actually sorts the function with the highest <code>self</code> time and flatten them at the root of the tree. It's an excellent way to identify a time-consuming function and you get its call stack right next to it. With this you know exactly <strong>which function is a problem and from where it was called</strong>.</p><p>This call tree</p><pre class="language-text"><code class="language-text">topLevel     // self 0<br>  first      // self 0<br>  second     // self 0<br>    third    // self 10<br>    fourth   // self 7<br>      fifth  // self 8</code></pre><p>Will give you this inverted call stack</p><pre class="language-text"><code class="language-text">third   //self 10<br>  second<br>    topLevel<br>fifth   // self 8<br>  fourth<br>    second<br>      topLevel<br>fourth  // self 7<br>  second<br>    topLevel</code></pre><p>So we can quickly identify that we spent ~10ms in <code>third</code> called from <code>topLevel &gt; second</code></p><h2 id="conclusion" tabindex="-1">Conclusion</h2><p>In this article we have covered the basic functions of the profiler. We have seen how to use the <code>call tree</code> and <code>inverted call stack</code> to quickly identify time consuming functions in your application.</p><p>Now those time consuming functions are not necessarily the functions that you need to optimize. The problem could lie on the parent function or even higher in the tree. The <code>inverted call stack</code> gives you a good starting point to walk your way up the problematic part of your app.</p><p>We have not covered here what the <code>Flame Graph</code> or <code>Stack Chart</code> are, how to profile async code or advanced techniques like <code>markers</code>. This is something I would love to cover in a follow up article. Feel free to ping me on <a href="https://twitter.com/atomrc">Twitter</a> if this would interest you ;)</p></div><br><em>You enjoyed this article? Consider <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/intent/tweet?url=https://blog.atomrc.dev/p/js-performance-profiling/&text=Get to know your browser's performance profiler&via=atomrc">tweeting it</a> :)</em></article><script src="/js/posts.js" async></script><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebSite",
      "@id": "https://blog.atomrc.dev#website",
      "url": "https://blog.atomrc.dev",
      "name": "Thomas Belin",
      "description": "Freelance Front-End Architect in Paris. I leave code cleaner than I found it. Seriously into Functional and Reactive Programming.",
      "inLanguage": "en"
    },
    {
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.atomrc.dev/p/js-performance-profiling/"
      },
      "url": "https://blog.atomrc.dev/p/js-performance-profiling/",
      "isPartOf": {
        "@id": "https://blog.atomrc.dev#website"
      },
      "headline": "Get to know your browser's performance profiler",
      "description": "The performance profiler can feel a little overwhelming and scary. But once you understand its basic principles it becomes the most powerful performance debugging tool",
      "image": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
      "inLanguage": "en",
      "publisher": {
        "@type": "Organization",
        "name": "Thomas Belin",
        "url": "https://blog.atomrc.dev#organization",
        "logo": {
          "@type": "ImageObject",
          "url": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
          "width": 300,
          "height": 300
        }
      },
      "author": {
        "@type": "Person",
        "name": "Thomas Belin"
      },
      "keywords": "posts,performance,javascript,firefox,chrome,browser",
      "datePublished": "2022-05-05T00:00:00.000Z"
    }
  ]
}</script></section><div id="footer">Made with <span class="love">♥</span>️ by <a href="https://twitter.com/atomrc" rel="noopener noreferrer">@atomrc</a></div></body></html>