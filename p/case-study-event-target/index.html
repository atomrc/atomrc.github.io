<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="alternate" type="application/rss+xml" title="Thomas Belin's Blog" href="https://blog.atomrc.dev/feed.xml"><link rel="icon" href="/favicon.ico"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><title>Monitoring: A case study for EventTarget - Thomas Belin</title><meta name="description" content="Lately, at Deezer, I have been implementing monitoring for a feature I was working on. I took this opportunity to document how I designed the monitoring mechanism to be as non-intrusive as possible"><meta name="author" content="Thomas Belin"><link rel="canonical" href="https://blog.atomrc.dev/p/case-study-event-target/"><meta name="color-scheme" content="dark light"><style>body{--ff-sans:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI","Ubuntu","Roboto","Noto Sans","Droid Sans",sans-serif;--ff-mono:ui-monospace,"Cascadia Mono","Segoe UI Mono","Ubuntu Mono","Roboto Mono",Menlo,Monaco,Consolas,monospace;padding:0;margin:0;color:var(--font-color);background-color:var(--bg-color);font-family:var(--ff-sans);font-size:13pt}body,body.light-mode{--font-color:#333;--font-secondary-color:#555;--bg-color:#fff;--title-color:#e7005d;--link-color:#0e4db5;--bg-code-color:#f6f6f6}body.dark-mode{--font-color:#ddd;--font-secondary-color:#aaa;--bg-color:#1c1c21;--title-color:var(--link-color);--link-color:rgb(88, 166, 255);--bg-code-color:#444}#dark-mode-toggle{border:none;background-color:transparent;position:fixed;top:1em;right:1em;z-index:1;height:24px;width:24px;overflow:hidden}#dark-mode-toggle svg{stroke:var(--font-color);fill:var(--font-color);transition:opacity .3s,fill .3s,stroke .3s;position:absolute;top:0;left:0}.dark-mode #dark-mode-toggle .moon,.light-mode #dark-mode-toggle .sun{opacity:0}a{text-decoration:none;color:var(--link-color)}ul{list-style:none;padding:0}.avatar{height:100px;width:100px;border-radius:50px}.title{color:var(--title-color)}.tag{font-size:10pt;color:var(--font-secondary-color);font-style:italic}#header{text-align:center;font-size:1.95em;padding:1em}#header .title{color:var(--font-color);font-weight:200}#footer{text-align:center;padding:2em}.love{color:red}#footer a{color:inherit;text-decoration:underline}</style><script async defer="defer" data-domain="atomrc.dev" src="https://plausible.io/js/plausible.js"></script></head><body><button id="dark-mode-toggle" aria-label="Toggle bewteen dark and light mode"><svg xmlns="http://www.w3.org/2000/svg" class="sun" stroke-linejoin="round" stroke-linecap="round" stroke-width="2" stroke="#000" fill="none" height="24" width="24"><circle r="5" cy="12" cx="12"/><path d="M12 1v2m0 18v2M4.22 4.22l1.42 1.42m12.72 12.72 1.42 1.42M1 12h2m18 0h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg><svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" class="moon"><path style="stroke-width:.0469517" d="M13.278 24.02c3.707 0 7.093-1.687 9.336-4.451a.564.564 0 0 0-.543-.909c-5.831 1.111-11.186-3.36-11.186-9.247a9.41 9.41 0 0 1 4.765-8.188.564.564 0 0 0-.176-1.044 12.12 12.12 0 0 0-2.196-.2C6.643-.02 1.258 5.356 1.258 12c0 6.635 5.376 12.02 12.02 12.02z"/></svg></button><script>(function (win, doc) {
  let isDarkMode =
    sessionStorage.getItem("darkmode") === undefined
      ? win.matchMedia("(prefers-color-scheme: dark)").matches
      : sessionStorage.getItem("darkmode") === "true";

  const toggleDarkMode = (setDarkMode) => {
    isDarkMode = setDarkMode ?? !isDarkMode;
    sessionStorage.setItem("darkmode", isDarkMode);
    if (isDarkMode) {
      document.body.classList.add("dark-mode");
      document.body.classList.remove("light-mode");
    } else {
      document.body.classList.remove("dark-mode");
      document.body.classList.add("light-mode");
    }
  };

  toggleDarkMode(isDarkMode);
  const darkModeToggle = doc.getElementById("dark-mode-toggle");

  darkModeToggle.addEventListener("click", () => toggleDarkMode());
})(window, document);</script><div id="header"><div><a href="/"><img class="avatar" src="https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=200" alt="Avatar"></a><br><a class="title" href="/"><span rel="author">Thomas Belin</span></a><br></div></div><section><link href="/css/article.css" rel="stylesheet" async defer="defer"><link href="/css/syntax.css" rel="stylesheet" async defer="defer"><style>article{max-width:800px;margin:auto;padding:0 1em;position:relative;line-height:1.5em}article h1{font-size:2em;font-weight:300;line-height:1.2em}article h2,article h3{position:relative;padding-bottom:.3em;font-weight:500;line-height:1.2em}article h2{font-size:2em;border-bottom:solid 1px #eee;margin:1em 0 .5em}article h3{font-size:1.5em;margin:1em 2em}article ul{list-style-type:disc;padding:0 2em}article img{border:solid 1px grey;display:block;max-width:90%;margin:auto}@media (prefers-color-scheme:dark){article h2{border-bottom:solid 1px #333}}</style><article lang="en"><header><h1 class="title">Monitoring: A case study for EventTarget</h1><aside><time class="folded-paper" datetime="2021-05-05T00:00:00.000Z" pubdate itemprop="datePublished" content="2021-05-05T00:00:00.000Z">05 <span class="month">May</span> 2021</time><br><span class="tag">posts</span>&nbsp; <span class="tag">eventtarget</span>&nbsp; <span class="tag">monitoring</span>&nbsp; <span class="tag">architecture</span>&nbsp;</aside></header><div class="article-body"><p>If you work for a data-driven company chances are you had to implement a tracker at some point.<br>I often see this step being rushed and written straight into the business code.<br>A lot of attention is given to having a clean implementation of the feature but little thoughts are given to how the tracking impacts the implementation.</p><p>Lately, at Deezer, I have been working on a feature that allows two devices to send messages to each other.<br>I thought this would be a nice opportunity to document my usual approach to monitoring üßë‚Äçüíª</p><p>For this, I set the following contraints:</p><ul><li>not a single mention of the tracking mechanism should appear in the business code;</li><li>deactivating the tracking feature should be a single-line change.</li></ul><h2 id="the-business-logic" tabindex="-1">The business logic</h2><p>We are going to focus on the method that sends a message to the remote peer. The method sends a message on the connection and waits for the peer to reply with an <code>ack</code> message before resolving the returned <code>Promise</code>.<br>(<em>The details of how the <code>ack</code> is matched is hidden in the <code>addAckListener</code> method for the sake of simplicity.</em>)</p><pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Connection</span> <span class="token punctuation">{</span><br>  <span class="token comment">// ...</span><br>  <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> messageId <span class="token operator">=</span> <span class="token function">uuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>peerConnection<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token function">uuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addAckListener</span><span class="token punctuation">(</span>messageId<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token operator">?</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> error <span class="token operator">?</span> <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>The metrics we want to monitor are the following:</p><ul><li>the number of successful messages;</li><li>the number of failed messages;</li><li>the time a message needs to do the round trip (between the message being sent and the <code>ack</code> being received).</li></ul><h2 id="a-naive-implementation" tabindex="-1">A naive implementation</h2><p>Before over-engineering anything I find it useful to start-off with a naive implementation.<br>It usually helps me clearing up the contraints before extracting them somewhere else.</p><p>The first thing that comes to mind is to add the tracking bits directly into the code that actually sends the message... Let's go for it ü§ì</p><pre class="language-diff"><code class="language-diff">class Connection {<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> // ...<br></span><span class="token prefix unchanged"> </span><span class="token line"> sendMessage(message) {<br></span><span class="token prefix unchanged"> </span><span class="token line">   const messageId = uuid();<br></span><span class="token prefix unchanged"> </span><span class="token line">   this.peerConnection.send({ id: uuid(), message });<br></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   const timer = Date.now(); // Keep track of the time the message was sent at<br></span></span><br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   return new Promise((resolve, reject) => {<br></span><span class="token prefix unchanged"> </span><span class="token line">     this.addAckListener(messageId, (error?: number) => {<br></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">       const elapsed = Date.now() - timer;<br></span><span class="token prefix inserted">+</span><span class="token line">       trackMetrics('latency', elapsed);<br></span><span class="token prefix inserted">+</span><span class="token line">       if (err) {<br></span><span class="token prefix inserted">+</span><span class="token line">         trackMetrics('message_error', err);<br></span><span class="token prefix inserted">+</span><span class="token line">       } else {<br></span><span class="token prefix inserted">+</span><span class="token line">         trackMetrics('message_success');<br></span><span class="token prefix inserted">+</span><span class="token line">       }<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">       return error ? reject(error) : resolve();<br></span><span class="token prefix unchanged"> </span><span class="token line">     });<br></span><span class="token prefix unchanged"> </span><span class="token line">   });<br></span><span class="token prefix unchanged"> </span><span class="token line"> }</span></span></code></pre><p>That is quite a bit of code that pollutes the actual business logic. The responsibility of the <code>sendMessage</code> has been altered. It cannot be described without an &quot;and&quot; in the sentence: It sends messages <strong>and</strong> tracks metrics.</p><p><strong>Pros</strong>:</p><ul><li>üëå easy to implement (almost a no-brainer)</li><li>üëå factorised (monitoring is implemented once and work for every message sent)</li></ul><p><strong>Cons</strong>:</p><ul><li>üëé strong impact on the business logic</li><li>üëé not trivial to deactivate (need to comment or condition many lines with the risk of disabling lines of actual business logic)</li></ul><h2 id="moving-the-tracking-logic-to-the-parent" tabindex="-1">Moving the tracking logic to the parent</h2><p>The <code>sendMessage</code> method returns a <code>Promise</code>. This is definitely something we can use!</p><p>Along with the value it holds, a <code>Promise</code> also carries around:</p><ul><li>the success state of the operation;</li><li>the time the operation took to complete (or to fail).</li></ul><p>This is exactly the pieces of information we need for our tracker üëå</p><p>Let's say the consumer does something like this:</p><pre class="language-js"><code class="language-js">connection<br>  <span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">"play"</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><br>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token function">showSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><br>  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token function">showError</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>We could easily plug our tracking mechanism right here:</p><pre class="language-diff"><code class="language-diff"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">const timer = Date.now();<br></span></span>connection<br><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> .sendMessage({ type: "play" /*...*/ })<br></span><span class="token prefix unchanged"> </span><span class="token line"> .then(() => {<br></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   trackMetrics('message_success');<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   showSuccess();<br></span><span class="token prefix unchanged"> </span><span class="token line"> })<br></span><span class="token prefix unchanged"> </span><span class="token line"> .catch((err) => {<br></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   trackMetrics('message_error', err);<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   showError(err);<br></span><span class="token prefix unchanged"> </span><span class="token line"> })<br></span><span class="token prefix unchanged"> </span><span class="token line"> .then(() => {<br></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   const elapsed = Date.now() - timer;<br></span><span class="token prefix inserted">+</span><span class="token line">   trackMetrics('latency', elapsed);<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> });</span></span></code></pre><p><strong>Pros</strong>:</p><ul><li>üëå easy to implement</li><li>üëå non intrusive (the business logic is left untouched)</li></ul><p><strong>Cons</strong>:</p><ul><li>üëé unfactorised (every call to <code>sendMessage</code> need to be modified)</li><li>üëé even harder to disable (need to disable <strong>all</strong> the placed where <code>sendMessage</code> is called)</li></ul><h2 id="extracting-the-monitoring-logic-to-a-separate-unit" tabindex="-1">Extracting the monitoring logic to a separate unit</h2><p>Our previous version allowed for the pure business logic to be left untouched. This is good. But now it is our view layer that is orchestrating the monitoring.</p><p>Maybe we could try to extract this logic somewhere else.</p><p>Another property of <code>Promise</code> is that it can be <strong>forked</strong>.</p><p>It is well known that <code>Promise</code> can be chained:</p><pre class="language-js"><code class="language-js">promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>doStuff<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>doOtherStuff<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>But we often forget that it can also be forked:</p><pre class="language-js"><code class="language-js">promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>doStuff<span class="token punctuation">)</span><span class="token punctuation">;</span><br>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>doOtherStuff<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>We could use that property to clean our view layer code.</p><p>This would be our implementation of our monitoring tool:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">trackMessage</span><span class="token punctuation">(</span><span class="token parameter">messagePromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> timer <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  messagePromise<br>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token function">trackMetrics</span><span class="token punctuation">(</span><span class="token string">"message_success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token function">trackMetrics</span><span class="token punctuation">(</span><span class="token string">"message_failed"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token keyword">const</span> elapsed <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timer<span class="token punctuation">;</span><br>      <span class="token function">trackMetrics</span><span class="token punctuation">(</span><span class="token string">"latency"</span><span class="token punctuation">,</span> elapsed<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">return</span> messagePromise<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Here we just plug-in some callback to execute after the promise <code>resolve</code>/<code>reject</code> and we return the initial, unmodified, promise.</p><p>The TypesScript signature is the following <code>trackMessage(messagePromise: Promise&lt;Payload&gt;): Promise&lt;Payload&gt;</code>.</p><p>Now the view layer code looks like this:</p><pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">connection.sendMessage({ type: "play" /*...*/ })<br></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">trackMessage(connection.sendMessage({ type: "play" /*...*/ }))<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> .then(showSuccess)<br></span><span class="token prefix unchanged"> </span><span class="token line"> .catch(showError);</span></span></code></pre><p><strong>Pros</strong>:</p><ul><li>üëå rather easy to implement</li><li>üëå a unit with a well defined responsibility (easy to test)</li><li>üëå low impact on the view layer</li><li>üëå no impact on the business logic</li></ul><p><strong>Cons</strong>:</p><ul><li>üëé unfactorised (every call to <code>sendMessage</code> need to be wrapped)</li><li>üëé hard to disable (every call to <code>sendMessage</code> need to be disabled)</li></ul><h2 id="events-to-the-rescue" tabindex="-1">Events to the rescue</h2><p>What we actually want is something that is completely transversal to our application code. What if we could leave the view layer intact and have very limited impact on the business logic?</p><p>Let's do an attempt based on events.</p><p>Events are nice for decoupling entirely business and plug-in features (like our tracking).</p><p>Let's go back to our <code>Connection</code> class</p><pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">class Connection {<br></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">class Connection extends EventTarget {<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> //...<br></span><span class="token prefix unchanged"> </span><span class="token line"> function sendMessage{<br></span><span class="token prefix unchanged"> </span><span class="token line">   return new Promise((resolve, reject) => {<br></span><span class="token prefix unchanged"> </span><span class="token line">     const messageId = uuid(); // We generate an id for that message<br></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     this.dispatchEvent(new CustomEvent('sendmessage', {detail: {id: messageId})));<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     peerConnection.send(msg);<br></span><span class="token prefix unchanged"> </span><span class="token line">     function handleAck({ type, ackId, err }) {<br></span><span class="token prefix unchanged"> </span><span class="token line">       if (type === "ack" &amp;&amp; ackId === messageId) {<br></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">         this.dispatchEvent(new CustomEvent('ackmessage', {detail: {id: messageId, err}}));<br></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">         peerConnection.removeMessageListener(handleAck);<br></span><span class="token prefix unchanged"> </span><span class="token line">         return !err ? resolve() : reject(err);<br></span><span class="token prefix unchanged"> </span><span class="token line">       }<br></span><span class="token prefix unchanged"> </span><span class="token line">     }<br></span><span class="token prefix unchanged"> </span><span class="token line">     peerConnection.addMessageListener(handleAck);<br></span><span class="token prefix unchanged"> </span><span class="token line">   });<br></span><span class="token prefix unchanged"> </span><span class="token line"> }<br></span></span>}</code></pre><p>Our business code needed a few modifications, that's true, but these are quite generic changes that are unrelated to tracking. You can think of it this way: if you extract this module to an external library, <strong>it has no unexpected side effects</strong>.</p><p>Now we can implement our monitoring module based on the <code>EventTarget</code> contract we just defined (I believe TypeScript will help reading the following):</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">monitorConnection</span><span class="token punctuation">(</span>connection<span class="token operator">:</span> Connection<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> timers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  connection<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><br>    <span class="token string">"sendmessage"</span><span class="token punctuation">,</span><br>    <span class="token punctuation">(</span><span class="token punctuation">{</span> detail <span class="token punctuation">}</span><span class="token operator">:</span> CustomEvent<span class="token operator">&lt;</span><span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      timers<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>detail<span class="token punctuation">.</span>id<span class="token punctuation">,</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token function">trackMetrics</span><span class="token punctuation">(</span><span class="token string">"latency"</span><span class="token punctuation">,</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>  connection<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><br>    <span class="token string">"ackmessage"</span><span class="token punctuation">,</span><br>    <span class="token punctuation">(</span><span class="token punctuation">{</span> detail <span class="token punctuation">}</span><span class="token operator">:</span> CustomEvent<span class="token operator">&lt;</span><span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> err<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token keyword">const</span> timer <span class="token operator">=</span> timers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>detail<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>detail<span class="token punctuation">.</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token function">trackMetrics</span><span class="token punctuation">(</span><span class="token string">"message_error"</span><span class="token punctuation">,</span> detail<span class="token punctuation">.</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token function">trackMetrics</span><span class="token punctuation">(</span><span class="token string">"message_success"</span><span class="token punctuation">,</span> detail<span class="token punctuation">.</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>      <span class="token function">trackMetrics</span><span class="token punctuation">(</span><span class="token string">"latency"</span><span class="token punctuation">,</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Finally we need to plug that code somewhere. This time it is going to be in the glue code that instantiate the <code>Connection</code>.</p><pre class="language-diff"><code class="language-diff">const connection = new Connection(/*...*/);<br><br><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">monitorConnection(connection);<br></span></span><br>//...<br>connection.sendMessage(message);</code></pre><p><strong>Pros</strong>:</p><ul><li>üëå factorised (all the monitoring logic is in a single place)</li><li>üëå a unit with a well defined responsibility (easily testable)</li><li>üëå low impact on the business logic</li><li>üëå very low impact on the global codebase</li><li>üëå trivial to deactivate (can be disabled by commenting/conditioning <strong>a single</strong> line of the code)</li></ul><p><strong>Cons</strong>:</p><ul><li>üëé slightly harder to implement (the matching of message ids need to be manually done)</li></ul><h2 id="conclusion" tabindex="-1">Conclusion</h2><p>Tracking is an excellent use case for <code>EventTarget</code>. It allows for the business code to be very generic and the tracking mechanism to be very distant from your application code.</p><p>In general <code>Events</code> are tailored for those kind of scenarios: Having something that work in parallel to something else. The <code>DOM</code> API works this way!<br>The <code>DOM</code> itself is made to display things but it allows us to hook into events that happen on the presentational layer. With a few <code>addEventListener</code> we can add very complex behaviours on top of the <code>DOM</code> but the <code>DOM</code> never knows about those.</p><p>This is the beauty of it, there is a generic contract (eg. 'I will send a <code>click</code> event whenever the user clicks somewhere' or 'I will send a <code>sendmessage</code> event every time a message is being sent') that allows us, web developer, to add behavior on top of it.</p><p>Word of caution, though, <code>Events</code> are great but should not be overused. Keep in mind that they can blur the readability of the codebase if used for core behaviours. In those cases coupling is the way to go üôÇ</p></div><br><em>You enjoyed this article? Consider <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/intent/tweet?url=https://blog.atomrc.dev/p/case-study-event-target/&text=Monitoring: A case study for EventTarget&via=atomrc">tweeting it</a> :)</em></article><script src="/js/posts.js" async></script><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebSite",
      "@id": "https://blog.atomrc.dev#website",
      "url": "https://blog.atomrc.dev",
      "name": "Thomas Belin",
      "description": "Freelance Front-End Architect in Paris. I leave code cleaner than I found it. Seriously into Functional and Reactive Programming.",
      "inLanguage": "en"
    },
    {
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.atomrc.dev/p/case-study-event-target/"
      },
      "url": "https://blog.atomrc.dev/p/case-study-event-target/",
      "isPartOf": {
        "@id": "https://blog.atomrc.dev#website"
      },
      "headline": "Monitoring: A case study for EventTarget",
      "description": "Lately, at Deezer, I have been implementing monitoring for a feature I was working on. I took this opportunity to document how I designed the monitoring mechanism to be as non-intrusive as possible",
      "image": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
      "inLanguage": "en",
      "publisher": {
        "@type": "Organization",
        "name": "Thomas Belin",
        "url": "https://blog.atomrc.dev#organization",
        "logo": {
          "@type": "ImageObject",
          "url": "https://www.gravatar.com/avatar/56f2389bd912f388cc79874ce65fc0dc?s=300",
          "width": 300,
          "height": 300
        }
      },
      "author": {
        "@type": "Person",
        "name": "Thomas Belin"
      },
      "keywords": "posts,eventtarget,monitoring,architecture",
      "datePublished": "2021-05-05T00:00:00.000Z"
    }
  ]
}</script></section><div id="footer">Made with <span class="love">‚ô•</span>Ô∏è by <a href="https://twitter.com/atomrc" rel="noopener noreferrer">@atomrc</a></div></body></html>