---
layout: talk-remark
title: "Reactive programming"
description: "Let's apply fonctionnal programming to streams"
categories: [javascript, reactive]
---

<style></style>
<textarea id="source">
layout: true

.foot[<i class="ion-social-twitter"></i> @atomrc]

---
class: center, middle, naked
name: intro

# Reactive Programming

---
class: center
# Let's code a spreadsheet

<table>
    <THEAD>
        <tr>
            <td>A</td>
            <td>B</td>
            <td>C = A + B</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><input id="a1" type=""></td>
            <td><input id="b1" type=""></td>
            <td><input id="c1" type=""> </td>
        </tr>
    </tbody>
</table>

---
## The over-interactive way

```html
<input id="a" onkeyup="computeAndRender">
<input id="b" onkeyup="computeAndRender">
<input id="c">
```

```javascript
var a, b;

function compute(a, b) {
    return a + b;
}

function render(c) {
    $("#c").val(c);
}

function computeAndRender(event) {
    var target = event.target;
    window[target.id] = target.value;

    var c = compute(window.a, window.b);

    render(c);
}
```

---
## The over-interactive way

<br><br><br>
## **What should happen when** user types in, for `#c` to be up-to-date?

---
## The over-interactive way

### problems:
- input `#a` and `#b` are responsible for calling `computeAndRender`
- `computeAndRender` is responsible for computing `c`
- `computeAndRender` is responsible for updating `#c`

---
## The unobtrusive-interactive way

```html
<input id="a">
<input id="b">
<input id="c">
```

```javascript
function compute(a, b) {
    return a + b;
}

function render(c) {
    $("#c").val(c);
}

$("#a, #b").on("keyup", function computeAndRender(/*event*/) {
    var a = $("#a").val();
    var b = $("#b").val();

    var c = compute(a, b);

    render(c);
});
```

---
## The unobtrusive-interactive way

<br><br><br>
## **What should I do when** `#a` and `#b` emit a keyup event, for `#c` to be up-to-date?

---
## The unobtrusive-interactive way

### problems:

`computeAndRender` is responsible for:
- getting the value of `#a` and `#b`
- computing `c`
- updating `#c`


---
## The unobtrusive-interactive-event-consumer way

```javascript
var inputValues = {};

function compute(a, b) {
    return a + b;
}

function render(c) {
    $("#c").val(c);
}

$("#a, #b").on("keyup", function computeAndRender(event) {
    var target = event.target;
    inputValues[target.id] = target.value;

    var c = compute(inputValues.a, inputValues.b);

    renderC(c);
});
```

---
## The unobtrusive-interactive-event-consumer way

<br><br><br>
## **What should I do with** the event the inputs are sending me, for `#c` to be up-to-date?

---
## The unobtrusive-interactive-event-consumer way

### problems:

`computeAndRender` is responsible for:
- ~~getting the value of `#a` and `#b`~~
- computing `c`
- updating `#c`

---
## the event-driven way

```javascript
$("#a, #b").on("keyup", function gatherValues(event) {
    inputValues[event.target.id] = event.target.value;
    $(document).trigger("valuesChange", inputValues);
})
```

--
```javascript
$(document).on("valuesChange", function computeC(event, values) {
    var c = values.a + values.b;
    $(document).trigger("cChange", c);
});
```

--
```javascript
$(document).on("cChange", function render(event, c) {
    $("#c").val(c);
});
```

---
## the event-driven way v2

```javascript
$("#a, #b").on("keyup", gatherValues)
$(document).on("valuesChange", computeC);
$(document).on("cChange", render);

function gatherValues(event) { /*...*/ }

function computeC(event, values) { /*...*/ }

function render(event, c) { /*...*/ }
```

---
## the event-driven way

## **What should I do when** user types in?

--
## **What should I do when** values are updated?

--
## **What should I do when** a new value of `c` is computed?

---
## Let's think the other way around

###~~**What should I do when ...?**~~

--
##**What do I depend on to play my part?**


---
## Declarative programming: what the program should do?

```javascript
function program(numbers) {
    return numbers
        .map(num => multBy2(num))

}
```

</textarea>

<script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/4.1.0/rx.lite.min.js"></script>
<script>
var O = Rx.Observable;
setTimeout(function () {
    var aInput = document.querySelector("#a1");
    var bInput = document.querySelector("#b1");
    var cInput = document.querySelector("#c1");

    var a$ = O
        .fromEvent(aInput, "keyup")
        .map(e => e.target.value);

    var b$ = O
        .fromEvent(bInput, "keyup")
        .map(e => e.target.value);

    var c$ = O
        .combineLatest(
            a$.startWith(''),
            b$.startWith(''),
            (a, b) => a + b
        );

    c$.subscribe(function (c) {
        cInput.value = c;
    })
}, 1000);
</script>

