---
layout: talk-remark
title: "Reactive programming"
description: "Let's apply fonctionnal programming to streams"
categories: [javascript, reactive]
---
<style>
    .box {
        color: white;
        background-color: #3e3e3e;
        border-radius: 5px;
        padding: 0.5em;
    }
    ul {
        list-style-type: none;
    }
    li.ok:before {
        color: green;
        content: "\2713";
    }
    li.ko:before {
        color: red;
        content: "\00D7";
    }
    .animate-from-bottom {
        position: absolute;
        top: 100%;
        transition: top 1s;
    }
    .entered .animate-from-bottom {
        top: 25%;
    }
</style>
<textarea id="source">
layout: true

.foot[<i class="ion-social-twitter"></i> @atomrc]

---
class: center, middle, naked
name: intro

# Reactive Programming

---
class: center
# Let's code a spreadsheet

<table>
    <THEAD>
        <tr>
            <td>A</td>
            <td>B</td>
            <td>C = A + B</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><input id="a1" type=""></td>
            <td><input id="b1" type=""></td>
            <td><input id="c1" type=""> </td>
        </tr>
    </tbody>
</table>

---
## The over-interactive way

```html
<input id="a" onkeyup="computeAndRender">
<input id="b" onkeyup="computeAndRender">
<input id="c">
```

```javascript
var inputValues = {}

function computeAndRender(event) {
    var target = event.target;
    inputValues[target.id] = target.value;

    var c = compute(inputValues.a, inputValues.b);

    render(c);
}

function compute(a, b) {
    return a + b;
}

function render(c) {
    $("#c").val(c);
}
```

---
## The over-interactive way

<br><br><br>
## **What should happen when** user types in, for `#c` to be up-to-date?

---
## The over-interactive way

![over interactive diagram](/images/over-interactive.png)

--
<div class="box animate-from-bottom">
    <ul>
        <li class="ko"> input #a and #b are responsible for calling computeAndRender</li>
        <li class="ko"> computeAndRender is responsible for computing c</li>
        <li class="ko"> computeAndRender is responsible for updating #c</li>
    </ul>
</div>

---
## The inobtrusive way

```javascript
var inputValues = {};

$("#a, #b").on("keyup", function computeAndRender(event) {
    var target = event.target;
    inputValues[target.id] = target.value;

    var c = compute(inputValues.a, inputValues.b);

    renderC(c);
});

function compute(a, b) {
    return a + b;
}

function render(c) {
    $("#c").val(c);
}
```

---
## The inobtrusive way

<br><br><br>
## **What should I do when** `#a` and `#b` emit a keyup event, for `#c` to be up-to-date?

---
## The inobtrusive way

![event driven diagram](/images/unobtrusive.png)

--
<div class="box animate-from-bottom">
    <ul>
        <li class="ok"> input a and b are independent</li>
        <li class="ko"> computeAndRender is responsible for computing c</li>
        <li class="ko"> computeAndRender is responsible for updating #c</li>
    </ul>
</div>

---
## the event-driven way

```javascript
$("#a, #b").on("keyup", function gatherValues(event) {
    inputValues[event.target.id] = event.target.value;
    $(document).trigger("valuesChange", inputValues);
})
```

--
```javascript
$(document).on("valuesChange", function computeC(event, values) {
    var c = values.a + values.b;
    $(document).trigger("cChange", c);
});
```

--
```javascript
$(document).on("cChange", function render(event, c) {
    $("#c").val(c);
});
```

---
## the event-driven way v2

```javascript
$("#a, #b").on("keyup", gatherValues)
$(document).on("valuesChange", computeC);
$(document).on("cChange", render);

function gatherValues(event) { /*...*/ }

function computeC(event, values) { /*...*/ }

function render(event, c) { /*...*/ }
```

---
## the event-driven way

## **What should I do when** user types in?

--
## **What should I do when** values are updated?

--
## **What should I do when** a new value of `c` is computed?

---
## the event-driven way
![event driven diagram](/images/event-driven.png)

--
<div class="box animate-from-bottom">
    <ul>
        <li class="ok"> input "a" and "b" are independent</li>
        <li class="ok"> "gatherValue" is only responsible for keeping values in memory</li>
        <li class="ok"> "update" only computes the new value of "c"</li>
        <li class="ok"> "render" only render the given "c" on the DOM</li>
        <li class="ko"> The level of decoupling is to damn high!</li>
        <li class="ko"> Semantically wrong: value changing over time !== event</li>
    </ul>
</div>

---
## the event-driven way (fixed)
![event driven diagram](/images/event-driven-fixed.png)

---
## Let's think the other way around

###~~**What should I do when ...?**~~

--
##**What data do I depend on to play my part?**

---
class: middle
## Time to go reactive!

---
## Time to go reactive!

I am `#c`, what data do I need to render?

--

The latest value of `c`

```javascript
c.subscribe(function render(c) {
    $("#c").val(c);
});
```

---
## Time to go reactive!

I am `c`, what data do I need to compute my value?

--

The latest value of `a` and `b`

```javascript
var c = Rx.Observable
    .combineLatest(
        a,
        b,
        function computeC(a, b) {
            return a + b
        }
    );
```

---
## Time to go reactive!

We are `a` and `b`, what data do we need to know our values?

--

The event emitted by `#a` and `#b`

```javascript
var a = Rx.Observable
    .fromEvent(aInput, "keyup")
    .map(function getValue(event) {
        return event.target.value;
    });

var b = Rx.Observable
    .fromEvent(bInput, "keyup")
    .map(function getValue(event) {
        return event.target.value;
    });
```

---
## Wrapping up

```javascript
var O = Rx.Observable;

var a = O.fromEvent($("#a"), "keyup")
    .map(function getValue(event) {
        return event.target.value;
    });

var b = O.fromEvent($("#b"), "keyup")
    .map(function getValue(event) {
        return event.target.value;
    });

var c = O.combineLatest(
    a,
    b,
    function computeC(a, b) {
        return a + b
    }
);

c.subscribe(function render(c) {
    $("#c").val(c);
});
```

---
## Reactive Programming

![reactive diagram](/images/reactive.png)

---
## Reactive Programming

![reactive splitted diagram](/images/reactive-splitted.png)

---
## Reactive Programming

![marble circuit](http://www.eurekakids.net/g/6666588-3/super-marble-run-vortex-circuit-for-marbles.jpg)
</textarea>

<script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/4.1.0/rx.lite.min.js"></script>
<script>
var O = Rx.Observable;
setTimeout(function () {
    var aInput = document.querySelector("#a1");
    var bInput = document.querySelector("#b1");
    var cInput = document.querySelector("#c1");

    var a$ = O
        .fromEvent(aInput, "keyup")
        .map(e => e.target.value);

    var b$ = O
        .fromEvent(bInput, "keyup")
        .map(e => e.target.value);

    var c$ = O
        .combineLatest(
            a$.startWith(''),
            b$.startWith(''),
            (a, b) => a + b
        );

    c$.subscribe(function (c) {
        cInput.value = c;
    })
}, 1000);
</script>

